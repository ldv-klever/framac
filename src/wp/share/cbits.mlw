(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2013                                               *)
(*    CEA (Commissariat a l'energie atomique et aux energies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* ---------------------------------------------------------------------- *)
(* --- cbits library: C-Integer Arithmetics for Alt-Ergo               --- *)
(* ---------------------------------------------------------------------- *)

(* Some properties of bit extration *)

axiom lnot_extraction: forall x,  i:int [bit_test(lnot(x),i)].
  0<=i -> bit_test (lnot(x), i) = notb (bit_test(x,i))
axiom land_extraction: forall x,y,i:int [bit_test(land(x, y),i)].
  0<=i -> bit_test (land(x, y), i) = andb (bit_test(x,i),bit_test(y,i))
axiom lor_extraction : forall x,y,i:int [bit_test(lor(x,y),i)].
  0<=i -> bit_test (lor(x,y), i) = orb  (bit_test(x,i),bit_test(y,i))
axiom lxor_extraction: forall x,y,i:int [bit_test(lxor(x,y),i)].
  0<=i -> bit_test (lxor(x,y),i) = xorb (bit_test(x,i),bit_test(y,i))

axiom lsl_extraction_sup: forall x,n,m:int [bit_test(lsl(x,n),m)].
  0<=n -> 0<=m -> m>=n -> bit_test(lsl(x,n),m)=bit_test(x,m-n)
axiom lsl_extraction_inf: forall x,n,m:int [bit_test(lsl(x,n),m)].
  0<=n -> 0<=m -> m< n -> bit_test(lsl(x,n),m)=false
axiom lsr_extraction:     forall x,n,m:int [bit_test(lsr(x,n),m)].
  0<=n -> 0<=m         -> bit_test(lsr(x,n),m)=bit_test(x,m+n)

axiom lsl1_extraction: forall i,j:int [bit_test(lsl(1,i),j)]. 
  0<=i -> 0<=j         -> bit_test(lsl(1,i),j) = eqb(i,j)

(* sint8 *)
axiom to_sint8_extraction_sup: forall x,i:int [is_sint8(x),bit_test(x,i)].
  7<=i -> is_sint8(x) -> x>=0 -> bit_test(x,i) = zlt(x,0)
axiom to_sint8_extraction_inf: forall x,i:int [bit_test(to_sint8(x),i)].
  0<=i<8 -> bit_test(to_sint8(x),i)=bit_test(x,i)
(* uint8 *)
axiom to_uint8_extraction_sup: forall x,i:int [is_uint8(x),bit_test(x,i)].
  8<=i -> is_uint8(x) -> bit_test(x,i)=false
axiom to_uint8_extraction_inf: forall x,i:int [bit_test(to_uint8(x),i)].
  0<=i<8 -> bit_test(to_uint8(x),i)=bit_test(x,i)

(* sint16 *)
axiom to_sint16_extraction_sup: forall x,i:int [is_sint16(x),bit_test(x,i)].
  15<=i -> is_sint16(x) -> bit_test(x,i) = zlt(x,0)
axiom to_sint16_extraction_inf: forall x,i:int [bit_test(to_sint16(x),i)].
  0<=i<16 -> bit_test(to_sint16(x),i)=bit_test(x,i)
(* uint16 *)
axiom to_uint16_extraction_sup: forall x,i:int [is_uint16(x),bit_test(x,i)].
  16<=i -> is_uint16(x) -> bit_test(x,i)=false
axiom to_uint16_extraction_inf: forall x,i:int [bit_test(to_uint16(x),i)].
  0<=i<16 -> bit_test(to_uint16(x),i)=bit_test(x,i)

(* sint32 *)
axiom to_sint32_extraction_sup: forall x,i:int [is_sint32(x),bit_test(x,i)].
  31<=i -> is_sint32(x) -> bit_test(x,i) = zlt(x,0)
axiom to_sint32_extraction_inf: forall x,i:int [bit_test(to_sint32(x),i)].
  0<=i<32 -> bit_test(to_sint32(x),i)=bit_test(x,i)
(* uint32 *)
axiom to_uint32_extraction_sup: forall x,i:int [is_uint32(x),bit_test(x,i)].
  32<=i -> is_uint32(x) -> bit_test(x,i)=false
axiom to_uint32_extraction_inf: forall x,i:int [bit_test(to_uint32(x),i)].
  0<=i<32 -> bit_test(to_uint32(x),i)=bit_test(x,i)

(* sint64 *)
axiom to_sint64_extraction_sup: forall x,i:int [is_sint64(x),bit_test(x,i)].
  63<=i -> is_sint64(x) -> bit_test(x,i) = zlt(x,0)
axiom to_sint64_extraction_inf: forall x,i:int [bit_test(to_sint64(x),i)].
  0<=i<64 -> bit_test(to_sint64(x),i)=bit_test(x,i)
(* uint64 *)
axiom to_uint64_extraction_sup: forall x,i:int [is_uint64(x),bit_test(x,i)].
  64<=i -> is_uint64(x) -> bit_test(x,i)=false
axiom to_uint64_extraction_inf: forall x,i:int [bit_test(to_uint64(x),i)].
  0<=i<64 -> bit_test(to_uint64(x),i)=bit_test(x,i)

(* Some C-Integer Bits Conversions are identity *)

(* Signed conversions *)

(* sint8 *)
axiom is_sint8_lnot : forall x:int [to_sint8(lnot(x))].
  is_sint8(x) -> lnot(x)=to_sint8(lnot(x))

axiom is_sint8_lxor : forall x,y:int [to_sint8(lxor(x,y))].
  is_sint8(x) -> is_sint8(y) -> lxor(x,y)=to_sint8(lxor(x,y))

axiom is_sint8_lor : forall x,y:int [to_sint8(lor(x,y))].
  is_sint8(x) -> is_sint8(y) -> lor(x,y)=to_sint8(lor(x,y))

axiom is_sint8_land : forall x,y:int [to_sint8(land(x,y))].
  is_sint8(x) -> is_sint8(y) -> land(x,y)=to_sint8(land(x,y))

axiom is_sint8_lsr : forall x,y:int [to_sint8(lsr(x,y))].
  0<=y -> is_sint8(x) -> lsr(x,y)=to_sint8(lsr(x,y))

axiom is_sint8_lsl1 :
  lsl(1,7)=128
axiom is_sint8_lsl1_inf : forall y:int [lsl(1,y)].
  0<=y<7 -> is_sint8(lsl(1,y))
axiom is_sint8_lsl1_sup : forall y:int [to_sint8(lsl(1,y))].
  8<=y -> 0=to_sint8(lsl(1,y))

(* sint16 *)
axiom is_sint16_lnot : forall x:int [to_sint16(lnot(x))].
  is_sint16(x) -> lnot(x)=to_sint16(lnot(x))

axiom is_sint16_lxor : forall x,y:int [to_sint16(lxor(x,y))].
  is_sint16(x) -> is_sint16(y) -> lxor(x,y)=to_sint16(lxor(x,y))

axiom is_sint16_lor : forall x,y:int [to_sint16(lor(x,y))].
  is_sint16(x) -> is_sint16(y) -> lor(x,y)=to_sint16(lor(x,y))

axiom is_sint16_land : forall x,y:int [to_sint16(land(x,y))].
  is_sint16(x) -> is_sint16(y) -> land(x,y)=to_sint16(land(x,y))

axiom is_sint16_lsr : forall x,y:int [to_sint16(lsr(x,y))].
  0<=y -> is_sint16(x) -> lsr(x,y)=to_sint16(lsr(x,y))

axiom is_sint16_lsl1 :
  lsl(1,15)=32768
axiom is_sint16_lsl1_inf : forall y:int [lsl(1,y)].
  0<=y<15 -> is_sint16(lsl(1,y))
axiom is_sint16_lsl1_sup : forall y:int [to_sint16(lsl(1,y))].
  16<=y -> 0=to_sint16(lsl(1,y))

(* sint32 *)
axiom is_sint32_lnot : forall x:int [to_sint32(lnot(x))].
  is_sint32(x) -> lnot(x)=to_sint32(lnot(x))

axiom is_sint32_lxor : forall x,y:int [to_sint32(lxor(x,y))].
  is_sint32(x) ->  is_sint32(y) -> lxor(x,y)=to_sint32(lxor(x,y))

axiom is_sint32_lor : forall x,y:int [to_sint32(lor(x,y))].
  is_sint32(x) -> is_sint32(y) -> lor(x,y)=to_sint32(lor(x,y))

axiom is_sint32_land : forall x,y:int [to_sint32(land(x,y))].
  is_sint32(x) -> is_sint32(y) -> land(x,y)=to_sint32(land(x,y))

axiom is_sint32_lsr : forall x,y:int [to_sint32(lsr(x,y))].
  0<=y -> is_sint32(x) -> lsr(x,y)=to_sint32(lsr(x,y))

axiom is_sint32_lsl1 :
  lsl(1,31)=2147483648
axiom is_sint32_lsl1_inf : forall y:int [lsl(1,y)].
  0<=y<31 -> is_sint32(lsl(1,y))
axiom is_sint32_lsl1_sup : forall y:int [to_sint32(lsl(1,y))].
  32<=y -> 0=to_sint32(lsl(1,y))

(* sint64 *)
axiom is_sint64_lnot : forall x:int [to_sint64(lnot(x))].
  is_sint64(x) -> lnot(x)=to_sint64(lnot(x))

axiom is_sint64_lxor : forall x,y:int [to_sint64(lxor(x,y))].
  is_sint64(x) ->  is_sint64(y) -> lxor(x,y)=to_sint64(lxor(x,y))

axiom is_sint64_lor : forall x,y:int [to_sint64(lor(x,y))].
  is_sint64(x) -> is_sint64(y) -> lor(x,y)=to_sint64(lor(x,y))

axiom is_sint64_land : forall x,y:int [to_sint64(land(x,y))].
  is_sint64(x) -> is_sint64(y) -> land(x,y)=to_sint64(land(x,y))

axiom is_sint64_lsr : forall x,y:int [to_sint64(lsr(x,y))].
  0<=y -> is_sint64(x) -> lsr(x,y)=to_sint64(lsr(x,y))

axiom is_sint64_lsl1 :
  lsl(1,63)=9223372036854775808
axiom is_sint64_lsl1_inf : forall y:int [lsl(1,y)].
  0<=y<63 -> is_sint64(lsl(1,y))
axiom is_sint64_lsl1_sup : forall y:int [to_sint64(lsl(1,y))].
  64<=y -> 0=to_sint64(lsl(1,y))

(* Unsigned conversions *)

(* uint8 *)
axiom is_uint8_lor : forall x,y:int [to_uint8(lor(x,y))].
  is_uint8(x) -> is_uint8(y) -> lor(x,y)=to_uint8(lor(x,y))

axiom is_uint8_land : forall x,y:int [to_uint8(land(x,y))].
  is_uint8(x) -> is_uint8(y) -> land(x,y)=to_uint8(land(x,y))

axiom is_uint8_lsr : forall x,y:int [to_uint8(lsr(x,y))].
  0<=y -> is_uint8(x) -> lsr(x,y)=to_uint8(lsr(x,y))

axiom is_uint8_lsl1_inf : forall y:int [to_uint8(lsl(1,y))].
  0<=y<8 -> lsl(1,y)=to_uint8(lsl(1,y))
axiom is_uint16_lsl1_sup : forall y:int [to_uint8(lsr(1,y))].
  8<=y -> 0=to_uint8(lsl(1,y))

(* uint16 *)
axiom is_uint16_lor : forall x,y:int [to_uint16(lor(x,y))].
  is_uint16(x) -> is_uint16(y) -> lor(x,y)=to_uint16(lor(x,y))

axiom is_uint16_land : forall x,y:int [to_uint16(land(x,y))].
  is_uint16(x) -> is_uint16(y) -> land(x,y)=to_uint16(land(x,y))

axiom is_uint16_lsr : forall x,y:int [to_uint16(lsr(x,y))].
  0<=y -> is_uint16(x) -> lsr(x,y)=to_uint16(lsr(x,y))

axiom is_uint16_lsl1_inf : forall y:int [to_uint16(lsr(1,y))].
  0<=y<16 -> lsr(1,y)=to_uint16(lsr(1,y))
axiom is_uint16_lsl1_sup : forall y:int [to_uint16(lsr(1,y))].
  16<=y -> 0=to_uint16(lsr(1,y))

(* uint32 *)
axiom is_uint32_lor : forall x,y:int [to_uint32(lor(x,y))].
  is_uint32(x) -> is_uint32(y) -> lor(x,y)=to_uint32(lor(x,y))

axiom is_uint32_land : forall x,y:int [to_uint32(land(x,y))].
  is_uint32(x) -> is_uint32(y) -> land(x,y)=to_uint32(land(x,y))

axiom is_uint32_lsr : forall x,y:int [to_uint32(lsr(x,y))].
  0<=y -> is_uint32(x) -> lsr(x,y)=to_uint32(lsr(x,y))

axiom is_uint32_lsl1_inf : forall y:int [to_uint32(lsr(1,y))].
  0<=y<32 -> lsr(1,y)=to_uint32(lsr(1,y))
axiom is_uint16_lsl1_sup : forall y:int [to_uint32(lsr(1,y))].
  32<=y -> 0=to_uint32(lsr(1,y))

(* uint64 *)
axiom is_uint64_lor : forall x,y:int [to_uint64(lor(x,y))].
  is_uint64(x) -> is_uint64(y) -> lor(x,y)=to_uint64(lor(x,y))

axiom is_uint64_land : forall x,y:int [to_uint64(land(x,y))].
  is_uint64(x) -> is_uint64(y) -> land(x,y)=to_uint64(land(x,y))

axiom is_uint64_lsr : forall x,y:int [to_uint64(lsr(x,y))].
  0<=y -> is_uint64(x) -> lsr(x,y)=to_uint64(lsr(x,y))

axiom is_uint64_lsl1_inf : forall y:int [to_uint64(lsr(1,y))].
  0<=y<64 -> lsr(1,y)=to_uint64(lsr(1,y))
axiom is_uint16_lsl1_sup : forall y:int [to_uint64(lsl(1,y))].
  64<=y -> 0=to_uint64(lsl(1,y))

(* End of cbits library *)
