(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2013                                               *)
(*    CEA (Commissariat a l'energie atomique et aux energies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* -------------------------------------------------------------------------- *)
(* --- Classical Sets for Alt-Ergo                                        --- *)
(* -------------------------------------------------------------------------- *)

type 'a set

logic empty : 'a set
logic singleton : 'a -> 'a set
logic ac union : 'a set,'a set -> 'a set
logic ac inter : 'a set,'a set -> 'a set
logic member : 'a,'a set -> prop
logic member_bool : 'a,'a set -> bool

logic range_all : int set (* [..] *)
logic range_sup : int -> int set (* [a..] *)
logic range_inf : int -> int set (* [..b] *)
logic range : int,int -> int set (* [a..b] *)

predicate eqset(a : 'a set,b : 'a set) =
  forall x : 'a. member(x,a) <-> member(x,b)

predicate subset(a : 'a set,b : 'a set) =
  forall x : 'a. member(x,a) -> member(x,b)

predicate disjoint(a : 'a set,b : 'a set) =
  forall x : 'a. member(x,a) -> member(x,b) -> false

(* -------------------------------------------------------------------------- *)

axiom member_bool : forall x:'a. forall s:'a set [member_bool(x,s)].
  if member_bool(x,s) then member(x,s) else not(member(x,s))

axiom member_empty : forall x:'a [member(x,empty)]. 
  not (member(x,empty))

axiom member_singleton : forall x,y:'a [member(x,singleton(y))].
  member(x,singleton(y)) <-> x=y

axiom member_union : forall x:'a. forall a,b:'a set [member(x,union(a,b))].
  member(x,union(a,b)) <-> member(x,a) or member(x,b)

axiom member_inter : forall x:'a. forall a,b:'a set [member(x,inter(a,b))].
  member(x,inter(a,b)) <-> member(x,a) and member(x,b)

axiom union_empty : forall a:'a set [union(a,empty)|union(empty,a)].
  union(a,empty) = a and union(empty,a) = a

axiom inter_empty : forall a:'a set [inter(a,empty)|inter(empty,a)].
  inter(a,empty) = empty and inter(empty,a) = empty

axiom member_range : forall x,a,b:int [member(x,range(a,b))].
  member(x,range(a,b)) <-> (a <= x and x <= b)

axiom member_range_sup : forall x,a:int [member(x,range_sup(a))].
  member(x,range_sup(a)) <-> (a <= x)

axiom member_range_inf : forall x,b:int [member(x,range_inf(b))].
  member(x,range_inf(b)) <-> (x <= b)

axiom member_range_all : forall x:int [member(x,range_all)].
  member(x,range_all)

