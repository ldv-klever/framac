(**************************************************************************)
(*                                                                        *)
(*  This file is part of WP plug-in of Frama-C.                           *)
(*                                                                        *)
(*  Copyright (C) 2007-2013                                               *)
(*    CEA (Commissariat a l'energie atomique et aux energies              *)
(*         alternatives)                                                  *)
(*                                                                        *)
(*  you can redistribute it and/or modify it under the terms of the GNU   *)
(*  Lesser General Public License as published by the Free Software       *)
(*  Foundation, version 2.1.                                              *)
(*                                                                        *)
(*  It is distributed in the hope that it will be useful,                 *)
(*  but WITHOUT ANY WARRANTY; without even the implied warranty of        *)
(*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *)
(*  GNU Lesser General Public License for more details.                   *)
(*                                                                        *)
(*  See the GNU Lesser General Public License version 2.1                 *)
(*  for more details (enclosed in the file licenses/LGPLv2.1).            *)
(*                                                                        *)
(**************************************************************************)

(* -------------------------------------------------------------------------- *)
(* --- Bool Library for Alt-Ergo                                          --- *)
(* -------------------------------------------------------------------------- *)

logic ite: bool,'a,'a -> 'a
axiom ite: forall p:bool. forall x,y:'a [ite(p,x,y)].
   ( p=true and ite(p,x,y)=x ) or
   ( p=false and ite(p,x,y)=y )

logic eqb: 'a,'a -> bool
axiom eqb: forall x,y:'a [eqb(x,y)]. if eqb(x,y) then x=y else x<>y

logic neqb: 'a,'a -> bool
axiom neqb: forall x,y:'a [neqb(x,y)]. if neqb(x,y) then x<>y else x=y

function xorb  (a:bool,b:bool):bool = neqb(a,b)
function notb  (a:bool):bool = if a then false else true
function orb   (a:bool,b:bool):bool = if a then true else b
function andb  (a:bool,b:bool):bool = if a then b else false
function implb (a:bool,b:bool):bool = if a then b else true

(* -------------------------------------------------------------------------- *)
(* --- Extension of Array Theory for Alt-Ergo                             --- *)
(* -------------------------------------------------------------------------- *)

axiom array: 
  forall k:'a. forall v:'b. forall m:('a,'b) farray [ m[k<-v] ]. m[k<-v][k]=v

(* -------------------------------------------------------------------------- *)
(* --- Arithmetic Library for Alt-Ergo                                    --- *)
(* -------------------------------------------------------------------------- *)

logic real_of_int : int -> real
logic int_of_real : real -> int

logic zlt :  int,int -> bool
axiom zlt :  forall x,y:int [zlt(x,y)]. if zlt(x,y) then x<y else x>=y

logic zleq : int,int -> bool
axiom zleq : forall x,y:int [zleq(x,y)]. if zleq(x,y) then x<=y else x>y

logic rlt :  real,real -> bool
axiom rlt :  forall x,y:real [rlt(x,y)]. if rlt(x,y) then x<y else x>=y

logic rleq : real,real -> bool
axiom rleq : forall x,y:real [rleq(x,y)]. if rleq(x,y) then x<=y else x>y

(* -------------------------------------------------------------------------- *)
(* --- Division   Library for Alt-Ergo                                    --- *)
(* -------------------------------------------------------------------------- *)

logic cdiv : int,int -> int
logic cmod : int,int -> int

axiom c_enclidian : forall n,d:int [cdiv(n,d),cmod(n,d)].
  n = cdiv(n,d) * d + cmod(n,d)

axiom cdiv_cases : forall n,d:int [cdiv(n,d)]. 
  ((n >= 0) -> (d > 0) -> cdiv(n,d) = n/d) and
  ((n <= 0) -> (d > 0) -> cdiv(n,d) = -((-n)/d)) and
  ((n >= 0) -> (d < 0) -> cdiv(n,d) = -(n/(-d))) and
  ((n <= 0) -> (d < 0) -> cdiv(n,d) = (-n)/(-d))

axiom cmod_cases : forall n,d:int [cmod(n,d)].
  ((n >= 0) -> (d > 0) -> cmod(n,d) = n % d) and
  ((n <= 0) -> (d > 0) -> cmod(n,d) = -((-n) % d)) and
  ((n >= 0) -> (d < 0) -> cmod(n,d) = (n % (-d))) and
  ((n <= 0) -> (d < 0) -> cmod(n,d) = -((-n) % (-d)))

axiom cmod_remainder : forall n,d:int [cmod(n,d)].
  ((n >= 0) -> (d > 0) ->  0 <= cmod(n,d) <  d) and
  ((n <= 0) -> (d > 0) -> -d <  cmod(n,d) <= 0) and
  ((n >= 0) -> (d < 0) ->  0 <= cmod(n,d) < -d) and
  ((n <= 0) -> (d < 0) ->  d <  cmod(n,d) <= 0)

axiom cdiv_neutral : forall a:int [cdiv(a,1)]. cdiv(a,1) = a
axiom cdiv_inv : forall a:int [cdiv(a,a)]. a<>0 -> cdiv(a,a) = 1
