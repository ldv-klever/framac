[kernel] Parsing share/libc/__fc_builtin_for_normalization.i (no preprocessing)
[kernel] Parsing tests/libc/fc_libc.c (with preprocessing)
/* Generated by Frama-C */
typedef unsigned int size_t;
struct option {
   char const *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef long long intmax_t;
struct __anonstruct_imaxdiv_t_1 {
   long long quot ;
   long long rem ;
};
typedef struct __anonstruct_imaxdiv_t_1 imaxdiv_t;
typedef int wchar_t;
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
typedef void * const * va_list;
typedef unsigned int ino_t;
typedef unsigned int gid_t;
typedef unsigned int uid_t;
typedef long time_t;
typedef unsigned int blkcnt_t;
typedef unsigned int blksize_t;
typedef unsigned int dev_t;
typedef unsigned int mode_t;
typedef unsigned int nlink_t;
typedef long off_t;
struct stat {
   dev_t st_dev ;
   ino_t st_ino ;
   mode_t st_mode ;
   nlink_t st_nlink ;
   uid_t st_uid ;
   gid_t st_gid ;
   dev_t st_rdev ;
   off_t st_size ;
   time_t st_atime ;
   time_t st_mtime ;
   time_t st_ctime ;
   blksize_t st_blksize ;
   blkcnt_t st_blocks ;
};
struct __fc_pos_t {
   unsigned long __fc_stdio_position ;
};
typedef struct __fc_pos_t fpos_t;
struct __fc_FILE {
   unsigned int __fc_FILE_id ;
   unsigned int __fc_FILE_data ;
};
typedef struct __fc_FILE FILE;
struct __fc_div_t {
   int quot ;
   int rem ;
};
typedef struct __fc_div_t div_t;
struct __fc_ldiv_t {
   long quot ;
   long rem ;
};
typedef struct __fc_ldiv_t ldiv_t;
struct __fc_lldiv_t {
   long long quot ;
   long long rem ;
};
typedef struct __fc_lldiv_t lldiv_t;
typedef unsigned int socklen_t;
typedef unsigned short sa_family_t;
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
typedef int ssize_t;
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   int msg_iovlen ;
   void *msg_control ;
   socklen_t msg_controllen ;
   int msg_flags ;
};
struct __fc_sockfds_type {
   int x ;
};
typedef uint32_t in_addr_t;
struct in_addr {
   in_addr_t s_addr ;
};
struct in6_addr {
   uint8_t s6_addr[16] ;
};
struct dirent {
   ino_t d_ino ;
   off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
struct DIR {
   unsigned int __fc_dir_id ;
   unsigned int __fc_dir_position ;
   struct stat *__fc_dir_inode ;
   struct dirent **__fc_dir_entries ;
};
typedef struct DIR DIR;
struct __anonstruct_fd_set_6 {
   char __fc_fd_set ;
};
typedef struct __anonstruct_fd_set_6 fd_set;
typedef unsigned int id_t;
typedef unsigned int pid_t;
typedef unsigned long sigset_t;
typedef int suseconds_t;
typedef unsigned int useconds_t;
struct flock {
   short l_type ;
   short l_whence ;
   off_t l_start ;
   off_t l_len ;
   pid_t l_pid ;
};
struct timeval {
   time_t tv_sec ;
   suseconds_t tv_usec ;
};
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
typedef void * iconv_t;
typedef int ( jmp_buf)[5];
struct __anonstruct_sigjmp_buf_14 {
   jmp_buf buf ;
   sigset_t sigs ;
};
typedef struct __anonstruct_sigjmp_buf_14 sigjmp_buf;
struct _code {
   char const *c_name ;
   int c_val ;
};
typedef struct _code CODE;
typedef unsigned long rlim_t;
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
};
typedef unsigned int clock_t;
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
};
struct tms {
   clock_t tms_utime ;
   clock_t tms_stime ;
   clock_t tms_cutime ;
   clock_t tms_cstime ;
};
typedef unsigned int tcflag_t;
typedef unsigned char cc_t;
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_cc[32] ;
};
int volatile Frama_C_entropy_source __attribute__((__unused__,
                                                   __FRAMA_C_MODEL__));
/*@ requires \valid(p + (0 .. l - 1));
    ensures \initialized(\old(p) + (0 .. \old(l) - 1));
    assigns *(p + (0 .. l - 1)), Frama_C_entropy_source;
    assigns *(p + (0 .. l - 1)) \from Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void Frama_C_make_unknown(char *p, size_t l);

int Frama_C_nondet(int a, int b);

void *Frama_C_nondet_ptr(void *a, void *b);

int Frama_C_interval(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_interval_split(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned char Frama_C_unsigned_char_interval(unsigned char min,
                                                    unsigned char max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern char Frama_C_char_interval(char min, char max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned short Frama_C_unsigned_short_interval(unsigned short min,
                                                      unsigned short max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern short Frama_C_short_interval(short min, short max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned int Frama_C_unsigned_int_interval(unsigned int min,
                                                  unsigned int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int Frama_C_int_interval(int min, int max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long Frama_C_unsigned_long_interval(unsigned long min,
                                                    unsigned long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long Frama_C_long_interval(long min, long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern unsigned long long Frama_C_unsigned_long_long_interval(unsigned long long min,
                                                              unsigned long long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern long long Frama_C_long_long_interval(long long min, long long max);

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern size_t Frama_C_size_t_interval(size_t min, size_t max);

float Frama_C_float_interval(float min, float max);

double Frama_C_double_interval(double min, double max);

/*@ assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
extern void *Frama_C_memcpy(void *dest, void const *src, size_t n);

/*@ assigns *((char *)p + (0 .. s - 1)), \result;
    assigns *((char *)p + (0 .. s - 1)) \from c;
    assigns \result \from p;
 */
extern void *Frama_C_memset(void *p, int c, size_t s);

/*@ requires \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void Frama_C_abort(void);

/*@ assigns \result;
    assigns \result \from p; */
extern size_t Frama_C_offset(void const *p);

extern void *Frama_C_malloc_fresh(size_t size);

void __FC_assert(char const *file, int line, char const *expr);

/*@ assigns \nothing; */
extern void Frama_C_show_each_warning();

/*@ requires \false;
    terminates \false;
    assigns \nothing; */
void __FC_assert(char const *file, int line, char const *expr)
{
  Frama_C_show_each_warning("Assertion may fail",file,line,expr);
  Frama_C_abort();
  return;
}

int isalnum(int c);

int isalpha(int c);

int isblank(int c);

int iscntrl(int c);

int isdigit(int c);

int isgraph(int c);

int islower(int c);

int isprint(int c);

int ispunct(int c);

int isspace(int c);

int isupper(int c);

int isxdigit(int c);

int tolower(int c);

int toupper(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes 0 ≤ c ≤ 127;
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes ¬(0 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
extern int isascii(int c);

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨
        (91 ≤ c ≤ 96) ∨ (123 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    behavior definitely_match:
      assumes
        ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z') ∨ ('0' ≤ c ≤ '9');
      ensures \result < 0 ∨ \result > 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int isalnum(int c)
{
  int tmp;
  if (c >= 'A') {
    if (c <= 'Z') tmp = 1; else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if (c >= 'a') {
      if (c <= 'z') tmp = 1; else goto _LAND;
    }
    else {
      _LAND: ;
      if (c >= '0') 
        if (c <= '9') tmp = 1; else tmp = 0;
      else tmp = 0;
    }
  }
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
        (123 ≤ c ≤ 127);
      ensures \result ≡ 0;
    
    behavior definitely_match:
      assumes ('A' ≤ c ≤ 'Z') ∨ ('a' ≤ c ≤ 'z');
      ensures \result < 0 ∨ \result > 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int isalpha(int c)
{
  int tmp;
  if (c >= 'A') {
    if (c <= 'Z') tmp = 1; else goto _LAND;
  }
  else {
    _LAND: ;
    if (c >= 'a') 
      if (c <= 'z') tmp = 1; else tmp = 0;
    else tmp = 0;
  }
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes c ≡ ' ' ∨ c ≡ '\t';
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c ≢ ' ' ∧ c ≢ '\t';
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
int isblank(int c)
{
  int tmp;
  if (c == ' ') tmp = 1;
  else 
    if (c == '\t') tmp = 1;
    else 
      if (c == ' ') tmp = 1;
      else 
        if (c == '\f') tmp = 1;
        else 
          if (c == '\n') tmp = 1;
          else 
            if (c == '\r') tmp = 1;
            else 
              if (c == '\t') tmp = 1;
              else 
                if (c == '\v') tmp = 1; else tmp = 0;
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (32 ≤ c ≤ 126);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int iscntrl(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes '0' ≤ c ≤ '9';
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes c < '0' ∨ c > '9';
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
int isdigit(int c)
{
  int tmp;
  if (c >= '0') 
    if (c <= '9') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 33 ≤ c ≤ 126;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int isgraph(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 'a' ≤ c ≤ 'z';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c < 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int islower(int c)
{
  int tmp;
  if (c >= 'a') 
    if (c <= 'z') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 32 ≤ c ≤ 126;
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c ≤ 31) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int isprint(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes
        (33 ≤ c ≤ 47) ∨ (58 ≤ c ≤ 64) ∨ (91 ≤ c ≤ 96) ∨
        (123 ≤ c ≤ 126);
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 32) ∨ (48 ≤ c ≤ 57) ∨
        (65 ≤ c ≤ 90) ∨ (97 ≤ c ≤ 122) ∨ c ≡ 127;
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int ispunct(int c)
{
  int tmp;
  tmp = Frama_C_nondet(0,1);
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes (9 ≤ c ≤ 13) ∨ c ≡ ' ';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes
        c ≡ -1 ∨ (0 ≤ c ≤ 8) ∨ (14 ≤ c < ' ') ∨
        (' ' < c ≤ 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int isspace(int c)
{
  int tmp;
  if (c == ' ') tmp = 1;
  else 
    if (c == '\f') tmp = 1;
    else 
      if (c == '\n') tmp = 1;
      else 
        if (c == '\r') tmp = 1;
        else 
          if (c == '\t') tmp = 1;
          else 
            if (c == '\v') tmp = 1; else tmp = 0;
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_match:
      assumes 'A' ≤ c ≤ 'Z';
      ensures \result < 0 ∨ \result > 0;
    
    behavior definitely_not_match:
      assumes c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures \result ≡ 0;
    
    disjoint behaviors definitely_match, definitely_not_match;
 */
int isupper(int c)
{
  int tmp;
  if (c >= 'A') 
    if (c <= 'Z') tmp = 1; else tmp = 0;
  else tmp = 0;
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior match:
      assumes
        ('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨ ('a' ≤ c ≤ 'f');
      ensures \result < 0 ∨ \result > 0;
    
    behavior no_match:
      assumes
        ¬(('0' ≤ c ≤ '9') ∨ ('A' ≤ c ≤ 'F') ∨
           ('a' ≤ c ≤ 'f'));
      ensures \result ≡ 0;
    
    complete behaviors match, no_match;
    disjoint behaviors match, no_match;
 */
int isxdigit(int c)
{
  int tmp;
  if (c >= '0') {
    if (c <= '9') tmp = 1; else goto _LAND_0;
  }
  else {
    _LAND_0: ;
    if (c >= 'a') {
      if (c <= 'f') tmp = 1; else goto _LAND;
    }
    else {
      _LAND: ;
      if (c >= 'A') 
        if (c <= 'F') tmp = 1; else tmp = 0;
      else tmp = 0;
    }
  }
  return tmp;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes 'A' ≤ c ≤ 'Z';
      ensures \result ≡ \old(c) + 32;
    
    behavior definitely_not_changed:
      assumes c ≡ -1 ∨ (0 ≤ c < 'A') ∨ ('Z' < c ≤ 127);
      ensures \result ≡ \old(c);
    
    disjoint behaviors definitely_changed, definitely_not_changed;
 */
int tolower(int c)
{
  int __retres;
  if (c >= 'A') 
    if (c <= 'Z') {
      __retres = c + 0x20;
      goto return_label;
    }
  __retres = c;
  return_label: return __retres;
}

/*@ requires (0 ≤ c ≤ 255) ∨ c ≡ -1;
    ensures (0 ≤ \result ≤ 255) ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from c;
    
    behavior definitely_changed:
      assumes 'a' ≤ c ≤ 'z';
      ensures \result ≡ \old(c) - 32;
    
    behavior definitely_not_changed:
      assumes c ≡ -1 ∨ (0 ≤ c < 'a') ∨ ('z' < c ≤ 127);
      ensures \result ≡ \old(c);
    
    disjoint behaviors definitely_changed, definitely_not_changed;
 */
int toupper(int c)
{
  int __retres;
  if (c >= 'a') 
    if (c <= 'z') {
      __retres = c - 0x20;
      goto return_label;
    }
  __retres = c;
  return_label: return __retres;
}

int __fc_errno;

int __fc_errno = 0;
extern char *optarg;

int optind;

extern int opterr;

extern int optopt;

/*@ assigns \result, *optarg, optind, opterr, optopt;
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(optstring + (0 ..));
 */
extern int getopt(int argc, char * const *argv, char const *optstring);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long(int argc, char * const *argv, char const *shortopts,
                       struct option const *longopts, int *longind);

/*@ assigns \result, *optarg, optind, opterr, optopt,
            *((longopts + (0 ..))->flag);
    assigns \result
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *optarg
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optind
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns opterr
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns optopt
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
    assigns *((longopts + (0 ..))->flag)
      \from argc, *(argv + (0 .. argc - 1)), *(shortopts + (0 ..)),
            *(longopts + (0 ..));
 */
extern int getopt_long_only(int argc, char * const *argv,
                            char const *shortopts,
                            struct option const *longopts, int *longind);

int optind = 1;
intmax_t imaxabs(intmax_t c);

imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);

/*@ assigns \result, *(endptr + (..)), __fc_errno;
    assigns \result \from *(nptr + (..)), base;
    assigns *(endptr + (..)) \from *(nptr + (..)), base;
    assigns __fc_errno \from *(nptr + (..)), base;
 */
extern intmax_t strtoimax(char const *nptr, char **endptr, int base);

/*@ requires (long long)(-c) ≢ c;
    assigns \result;
    assigns \result \from c;
 */
intmax_t imaxabs(intmax_t c)
{
  intmax_t __retres;
  if (c > (intmax_t)0) {
    __retres = c;
    goto return_label;
  }
  else {
    __retres = - c;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires denom ≢ 0;
    ensures \result.quot ≡ \old(numer) / \old(denom);
    ensures \result.rem ≡ \old(numer) % \old(denom);
    assigns \result;
    assigns \result \from numer, denom;
 */
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom)
{
  imaxdiv_t r;
  r.quot = numer / denom;
  r.rem = numer % denom;
  return r;
}

/*@
axiomatic MemCmp {
  logic ℤ memcmp{L1, L2}(char *s1, char *s2, ℤ n) 
    reads \at(*(s1 + (0 .. n - 1)),L1), \at(*(s2 + (0 .. n - 1)),L2);
  
  axiom memcmp_zero{L1, L2}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L1, L2}(s1, s2, n) ≡ 0 ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ \at(*(s1 + i),L1) ≡ \at(*(s2 + i),L2));
  
  }
 */
/*@
axiomatic MemChr {
  logic 𝔹 memchr{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memchr(s, c, n) ≡ \true ⇔
      (∃ int i; 0 ≤ i < n ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic MemSet {
  logic 𝔹 memset{L}(char *s, ℤ c, ℤ n) 
    reads *(s + (0 .. n - 1));
  
  axiom memset_def{L}:
    ∀ char *s;
    ∀ ℤ c;
    ∀ ℤ n;
      memset(s, c, n) ≡ \true ⇔
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic StrLen {
  logic ℤ strlen{L}(char *s) 
    reads *(s + (0 ..));
  
  axiom strlen_pos_or_null{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ '\000') ∧
      *(s + i) ≡ '\000' ⇒ strlen(s) ≡ i;
  
  axiom strlen_neg{L}:
    ∀ char *s;
      (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ '\000') ⇒ strlen(s) < 0;
  
  axiom strlen_before_null{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i < strlen(s) ⇒ *(s + i) ≢ '\000';
  
  axiom strlen_at_null{L}:
    ∀ char *s; 0 ≤ strlen(s) ⇒ *(s + strlen(s)) ≡ '\000';
  
  axiom strlen_not_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≢ '\000' ⇒ i < strlen(s);
  
  axiom strlen_zero{L}:
    ∀ char *s;
    ∀ ℤ i;
      0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ '\000' ⇒ i ≡ strlen(s);
  
  axiom strlen_sup{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_shift{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ≤ strlen(s) ⇒ strlen(s + i) ≡ strlen(s) - i;
  
  axiom strlen_create{L}:
    ∀ char *s;
    ∀ ℤ i; 0 ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s) ≤ i;
  
  axiom strlen_create_shift{L}:
    ∀ char *s;
    ∀ ℤ i;
    ∀ ℤ k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ '\000' ⇒ 0 ≤ strlen(s + k) ≤ i - k;
  
  axiom memcmp_strlen_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s1) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      memcmp{L, L}(s1, s2, n) ≡ 0 ∧ strlen(s2) < n ⇒
      strlen(s1) ≡ strlen(s2);
  
  axiom memcmp_strlen_shift_left{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1, s2 + k, n) ≡ 0 ≤ k ∧ strlen(s1) < n ⇒
      0 ≤ strlen(s2) ≤ k + strlen(s1);
  
  axiom memcmp_strlen_shift_right{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ k, ℤ n;
      memcmp{L, L}(s1 + k, s2, n) ≡ 0 ≤ k ∧ strlen(s2) < n ⇒
      0 ≤ strlen(s1) ≤ k + strlen(s2);
  
  }
 */
/*@
axiomatic StrCmp {
  logic ℤ strcmp{L}(char *s1, char *s2) 
    reads *(s1 + (0 .. strlen(s1))), *(s2 + (0 .. strlen(s2)));
  
  axiom strcmp_zero{L}:
    ∀ char *s1, char *s2;
      strcmp(s1, s2) ≡ 0 ⇔
      strlen(s1) ≡ strlen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ strlen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrNCmp {
  logic ℤ strncmp{L}(char *s1, char *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom strncmp_zero{L}:
    ∀ char *s1, char *s2;
    ∀ ℤ n;
      strncmp(s1, s2, n) ≡ 0 ⇔
      (strlen(s1) < n ∧ strcmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic StrChr {
  logic 𝔹 strchr{L}(char *s, ℤ c) 
    reads *(s + (0 .. strlen(s)));
  
  axiom strchr_def{L}:
    ∀ char *s;
    ∀ ℤ c;
      strchr(s, c) ≡ \true ⇔
      (∃ ℤ i; 0 ≤ i ≤ strlen(s) ∧ *(s + i) ≡ c);
  
  }
 */
/*@
axiomatic WcsLen {
  logic ℤ wcslen{L}(wchar_t *s) 
    reads *(s + (0 ..));
  
  axiom wcslen_pos_or_null{L}:
    ∀ wchar_t *s;
    ∀ ℤ i;
      0 ≤ i ∧ (∀ ℤ j; 0 ≤ j < i ⇒ *(s + j) ≢ 0) ∧
      *(s + i) ≡ 0 ⇒ wcslen(s) ≡ i;
  
  axiom wcslen_neg{L}:
    ∀ wchar_t *s; (∀ ℤ i; 0 ≤ i ⇒ *(s + i) ≢ 0) ⇒ wcslen(s) < 0;
  
  axiom wcslen_before_null{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i < wcslen(s) ⇒ *(s + i) ≢ 0;
  
  axiom wcslen_at_null{L}:
    ∀ wchar_t *s; 0 ≤ wcslen(s) ⇒ *(s + wcslen(s)) ≡ 0;
  
  axiom wcslen_not_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≢ 0 ⇒ i < wcslen(s);
  
  axiom wcslen_zero{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ∧ *(s + i) ≡ 0 ⇒ i ≡ wcslen(s);
  
  axiom wcslen_sup{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_shift{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ≤ wcslen(s) ⇒ wcslen(s + i) ≡ wcslen(s) - i;
  
  axiom wcslen_create{L}:
    ∀ wchar_t *s;
    ∀ int i; 0 ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s) ≤ i;
  
  axiom wcslen_create_shift{L}:
    ∀ wchar_t *s;
    ∀ int i;
    ∀ int k;
      0 ≤ k ≤ i ∧ *(s + i) ≡ 0 ⇒ 0 ≤ wcslen(s + k) ≤ i - k;
  
  }
 */
/*@
axiomatic WcsCmp {
  logic ℤ wcscmp{L}(wchar_t *s1, wchar_t *s2) 
    reads *(s1 + (0 .. wcslen(s1))), *(s2 + (0 .. wcslen(s2)));
  
  axiom wcscmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
      wcscmp(s1, s2) ≡ 0 ⇔
      wcslen(s1) ≡ wcslen(s2) ∧
      (∀ ℤ i; 0 ≤ i ≤ wcslen(s1) ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@
axiomatic WcsNCmp {
  logic ℤ wcsncmp{L}(wchar_t *s1, wchar_t *s2, ℤ n) 
    reads *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
  
  axiom wcsncmp_zero{L}:
    ∀ wchar_t *s1, wchar_t *s2;
    ∀ ℤ n;
      wcsncmp(s1, s2, n) ≡ 0 ⇔
      (wcslen(s1) < n ∧ wcscmp(s1, s2) ≡ 0) ∨
      (∀ ℤ i; 0 ≤ i < n ⇒ *(s1 + i) ≡ *(s2 + i));
  
  }
 */
/*@ logic ℤ minimum(ℤ i, ℤ j) = i < j? i: j;
 */
/*@ logic ℤ maximum(ℤ i, ℤ j) = i < j? j: i;
 */
/*@
predicate valid_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid(s + (0 .. strlen(s)));
 */
/*@
predicate valid_read_string{L}(char *s) =
  0 ≤ strlen(s) ∧ \valid_read(s + (0 .. strlen(s)));
 */
/*@
predicate valid_string_or_null{L}(char *s) = s ≡ \null ∨ valid_string(s);
 */
/*@
predicate valid_wstring{L}(wchar_t *s) =
  0 ≤ wcslen(s) ∧ \valid(s + (0 .. wcslen(s)));
 */
/*@
predicate valid_wstring_or_null{L}(wchar_t *s) =
  s ≡ \null ∨ valid_wstring(s);

*/
struct lconv *__frama_c_locale;

char *__frama_c_locale_names[1];

char *setlocale(int category, char const *locale);

struct lconv *localeconv(void);

struct lconv __C_locale =
  {.decimal_point = (char *)".",
   .thousands_sep = (char *)"",
   .grouping = (char *)"",
   .int_curr_symbol = (char *)"",
   .currency_symbol = (char *)"",
   .mon_decimal_point = (char *)"",
   .mon_thousands_sep = (char *)"",
   .mon_grouping = (char *)"",
   .positive_sign = (char *)"",
   .negative_sign = (char *)"",
   .int_frac_digits = (char)127,
   .frac_digits = (char)127,
   .p_cs_precedes = (char)127,
   .p_sep_by_space = (char)127,
   .n_cs_precedes = (char)127,
   .n_sep_by_space = (char)127,
   .p_sign_posn = (char)127,
   .n_sign_posn = (char)127,
   .int_p_cs_precedes = (char)127,
   .int_p_sep_by_space = (char)127,
   .int_n_cs_precedes = (char)127,
   .int_n_sep_by_space = (char)127,
   .int_p_sign_posn = (char)127,
   .int_n_sign_posn = (char)127};
struct lconv *__frama_c_locale = & __C_locale;
char *__frama_c_locale_names[1] = {(char *)"C"};
/*@ requires locale ≡ \null ∨ valid_read_string(locale);
    ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ (∃ ℤ i; \result ≡ __frama_c_locale_names[i]));
    assigns __frama_c_locale, \result;
    assigns __frama_c_locale \from category, *(locale + (..));
    assigns \result \from __frama_c_locale, category, *(locale + (..));
 */
char *setlocale(int category, char const *locale)
{
  char *__retres;
  if ((int)*locale == 'C') {
    __frama_c_locale = & __C_locale;
    __retres = __frama_c_locale_names[0];
    goto return_label;
  }
  __retres = (char *)0;
  return_label: return __retres;
}

/*@ ensures \result ≡ __frama_c_locale;
    assigns \nothing; */
struct lconv *localeconv(void)
{
  return __frama_c_locale;
}

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, edom;
 */
extern double acos(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, edom;
 */
extern float acosf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, edom;
 */
extern long double acosl(long double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, edom;
 */
extern double asin(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, edom;
 */
extern float asinf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ \abs(x) ≤ 1;
      ensures \is_finite(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_infinite(x) ∨ (\is_finite(x) ∧ \abs(x) > 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, edom;
 */
extern long double asinl(long double x);

/*@ assigns \result;
    assigns \result \from y, x; */
extern double atan2(double y, double x);

double cos(double x);

double sin(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern double acosh(double x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern float acoshf(float x);

/*@ behavior normal:
      assumes \is_finite(x) ∧ x ≥ 1;
      ensures \is_finite(\result) ∧ \result ≥ 0;
      assigns \nothing;
    
    behavior infinite:
      assumes \is_plus_infinity(x);
      ensures \is_plus_infinity(\result);
      assigns \nothing;
    
    behavior edom:
      assumes \is_minus_infinity(x) ∨ (\is_finite(x) ∧ x < 1);
      ensures __fc_errno ≡ 1;
      assigns __fc_errno;
    
    disjoint behaviors normal, infinite, edom;
 */
extern long double acoshl(long double x);

double exp(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float expf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double log(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float logf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double log10(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float log10f(float x);

double fabs(double x);

/*@ assigns \result;
    assigns \result \from x, y; */
extern double pow(double x, double y);

/*@ assigns \result;
    assigns \result \from x, y; */
extern float powf(float x, float y);

double sqrt(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float sqrtf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double ceil(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float ceilf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double floor(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float floorf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double round(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float roundf(float x);

/*@ assigns \result;
    assigns \result \from x; */
extern double trunc(double x);

/*@ assigns \result;
    assigns \result \from x; */
extern float truncf(float x);

/*@ assigns \result;
    assigns \result \from x, y; */
extern double fmod(double x, double y);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern double nan(char const *tagp);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern float nanf(char const *tagp);

/*@ requires valid_read_string(tagp);
    ensures \is_NaN(\result);
    assigns \nothing;
 */
extern long double nanl(char const *tagp);

/*@ assigns \result;
    assigns \result \from x; */
extern double Frama_C_exp(double x);

/*@ assigns \result;
    assigns \result \from x; */
double exp(double x)
{
  double tmp;
  tmp = Frama_C_exp(x);
  return tmp;
}

/*@ assigns \result;
    assigns \result \from x; */
extern double Frama_C_cos(double x);

/*@ assigns \result;
    assigns \result \from x; */
double cos(double x)
{
  double tmp;
  tmp = Frama_C_cos(x);
  return tmp;
}

/*@ assigns \result;
    assigns \result \from x; */
extern double Frama_C_sin(double x);

/*@ assigns \result;
    assigns \result \from x; */
double sin(double x)
{
  double tmp;
  tmp = Frama_C_sin(x);
  return tmp;
}

/*@ assigns \result;
    assigns \result \from x; */
extern double Frama_C_sqrt(double x);

/*@ assigns \result;
    assigns \result \from x; */
double sqrt(double x)
{
  double tmp;
  tmp = Frama_C_sqrt(x);
  return tmp;
}

double fabs(double x)
{
  double __retres;
  if (x == 0.0) {
    __retres = 0.0;
    goto return_label;
  }
  if (x > 0.0) {
    __retres = x;
    goto return_label;
  }
  __retres = - x;
  return_label: return __retres;
}

FILE *__fc_stderr;

FILE *__fc_stdin;

FILE *__fc_stdout;

/*@ assigns \nothing; */
extern int remove(char const *filename);

/*@ assigns \nothing; */
extern int rename(char const *old_name, char const *new_name);

/*@ ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ \fresh{Old, Here}(\result,sizeof(FILE)));
    assigns \nothing;
 */
extern FILE *tmpfile(void);

/*@ assigns \result, *(s + (..));
    assigns \result \from *(s + (..));
    assigns *(s + (..)) \from \nothing;
 */
extern char *tmpnam(char *s);

/*@ requires \valid(stream);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from stream, stream->__fc_FILE_id;
 */
extern int fclose(FILE *stream);

/*@ requires stream ≡ \null ∨ \valid_read(stream);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result;
    assigns \result \from stream, stream->__fc_FILE_id;
 */
extern int fflush(FILE *stream);

FILE __fc_fopen[512];
FILE * const __fc_p_fopen = __fc_fopen;
/*@ ensures
      \result ≡ \null ∨ \subset(\result, &__fc_fopen[0 .. 512 - 1]);
    assigns \result;
    assigns \result \from *(filename + (..)), *(mode + (..)), __fc_p_fopen;
 */
extern FILE *fopen(char const *filename, char const *mode);

/*@ ensures
      \result ≡ \null ∨
      (\valid(\result) ∧ \fresh{Old, Here}(\result,sizeof(FILE)));
    assigns \result;
    assigns \result \from fildes, *(mode + (..));
 */
extern FILE *fdopen(int fildes, char const *mode);

/*@ ensures \result ≡ \null ∨ \result ≡ \old(stream);
    assigns *stream;
 */
extern FILE *freopen(char const *filename, char const *mode, FILE *stream);

/*@ assigns *stream;
    assigns *stream \from buf; */
extern void setbuf(FILE *stream, char *buf);

/*@ assigns *stream;
    assigns *stream \from buf, mode, size; */
extern int setvbuf(FILE *stream, char *buf, int mode, size_t size);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), arg; */
extern int vfprintf(FILE *stream, char const *format, va_list arg);

/*@ assigns *stream;
    assigns *stream \from *(format + (..)), *stream; */
extern int vfscanf(FILE *stream, char const *format, va_list arg);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from arg; */
extern int vprintf(char const *format, va_list arg);

/*@ assigns *__fc_stdin;
    assigns *__fc_stdin \from *(format + (..)); */
extern int vscanf(char const *format, va_list arg);

/*@ assigns *(s + (0 .. n - 1));
    assigns *(s + (0 .. n - 1)) \from *(format + (..)), arg;
 */
extern int vsnprintf(char *s, size_t n, char const *format, va_list arg);

/*@ assigns *(s + (0 ..));
    assigns *(s + (0 ..)) \from *(format + (..)), arg;
 */
extern int vsprintf(char *s, char const *format, va_list arg);

/*@ assigns *stream; */
extern int fgetc(FILE *stream);

/*@ ensures \result ≡ \null ∨ \result ≡ \old(s);
    assigns *(s + (0 .. n - 1)), *stream, \result;
    assigns *(s + (0 .. n - 1)) \from *stream;
    assigns *stream \from *stream;
    assigns \result \from s, n, *stream;
 */
extern char *fgets(char *s, int n, FILE *stream);

/*@ assigns *stream; */
extern int fputc(int c, FILE *stream);

/*@ assigns *stream;
    assigns *stream \from *(s + (..)); */
extern int fputs(char const *s, FILE *stream);

/*@ assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar(void);

/*@ ensures \result ≡ \old(s) ∨ \result ≡ \null;
    assigns *(s + (..)), \result;
    assigns *(s + (..)) \from *__fc_stdin;
    assigns \result \from s, __fc_stdin;
 */
extern char *gets(char *s);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int putc(int c, FILE *stream);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from c; */
extern int putchar(int c);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from *(s + (..)); */
extern int puts(char const *s);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int ungetc(int c, FILE *stream);

/*@ requires \valid((char *)ptr + (0 .. nmemb * size - 1));
    requires \valid(stream);
    ensures \result ≤ \old(nmemb);
    ensures
      \initialized((char *)\old(ptr) + (0 .. \result * \old(size) - 1));
    assigns *((char *)ptr + (0 .. nmemb * size - 1)), \result;
    assigns *((char *)ptr + (0 .. nmemb * size - 1))
      \from size, nmemb, *stream;
    assigns \result \from size, *stream;
 */
extern size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);

/*@ requires \valid_read((char *)ptr + (0 .. nmemb * size - 1));
    requires \valid(stream);
    ensures \result ≤ \old(nmemb);
    assigns *stream, \result;
    assigns *stream \from *((char *)ptr + (0 .. nmemb * size - 1));
    assigns \result \from *((char *)ptr + (0 .. nmemb * size - 1));
 */
extern size_t fwrite(void const *ptr, size_t size, size_t nmemb, FILE *stream);

/*@ assigns *pos;
    assigns *pos \from *stream; */
extern int fgetpos(FILE *stream, fpos_t *pos);

/*@ requires \valid(stream);
    requires whence ≡ 0 ∨ whence ≡ 1 ∨ whence ≡ 2;
    assigns *stream, \result, __fc_errno;
    assigns *stream \from *stream, (indirect: offset), (indirect: whence);
    assigns \result
      \from (indirect: *stream), (indirect: offset), (indirect: whence);
    assigns __fc_errno
      \from (indirect: *stream), (indirect: offset), (indirect: whence);
 */
extern int fseek(FILE *stream, long offset, int whence);

/*@ assigns *stream;
    assigns *stream \from *pos; */
extern int fsetpos(FILE *stream, fpos_t const *pos);

/*@ assigns \result, __fc_errno;
    assigns \result \from *stream;
    assigns __fc_errno \from *stream;
 */
extern long ftell(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void rewind(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void clearerr(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int feof(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int fileno(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void flockfile(FILE *stream);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void funlockfile(FILE *stream);

/*@ assigns \result, *stream;
    assigns \result \from \nothing;
    assigns *stream \from \nothing;
 */
extern int ftrylockfile(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int ferror(FILE *stream);

/*@ assigns __fc_stdout;
    assigns __fc_stdout \from __fc_errno, *(s + (..));
 */
extern void perror(char const *s);

/*@ assigns \result, *stream;
    assigns \result \from *stream;
    assigns *stream \from *stream;
 */
extern int getc_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *__fc_stdin; */
extern int getchar_unlocked(void);

/*@ assigns *stream;
    assigns *stream \from c; */
extern int putc_unlocked(int c, FILE *stream);

/*@ assigns *__fc_stdout;
    assigns *__fc_stdout \from c; */
extern int putchar_unlocked(int c);

/*@ assigns *stream;
    assigns *stream \from \nothing; */
extern void clearerr_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int feof_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int ferror_unlocked(FILE *stream);

/*@ assigns \result;
    assigns \result \from *stream; */
extern int fileno_unlocked(FILE *stream);

FILE __fc_initial_stdout =
  {.__fc_FILE_id = (unsigned int)1, .__fc_FILE_data = 0U};
FILE *__fc_stdout = & __fc_initial_stdout;
FILE __fc_initial_stderr =
  {.__fc_FILE_id = (unsigned int)2, .__fc_FILE_data = 0U};
FILE *__fc_stderr = & __fc_initial_stderr;
FILE __fc_initial_stdin =
  {.__fc_FILE_id = (unsigned int)0, .__fc_FILE_data = 0U};
FILE *__fc_stdin = & __fc_initial_stdin;
/*@ requires \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
extern double atof(char const *nptr);

int atoi(char const *p);

/*@ requires \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
extern long atol(char const *nptr);

/*@ requires \valid_read(nptr);
    assigns \result;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
 */
extern long long atoll(char const *nptr);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern double strtod(char const *nptr, char **endptr);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \valid_read(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern float strtof(char const *nptr, char **endptr);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    assigns \result, *endptr;
    assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \valid_read(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result \from (indirect: nptr), (indirect: *(nptr + (0 ..)));
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern long double strtold(char const *nptr, char **endptr);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    requires base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \valid_read(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern long strtol(char const *nptr, char **endptr, int base);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    requires base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \valid_read(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern long long strtoll(char const *nptr, char **endptr, int base);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    requires base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \valid_read(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern unsigned long strtoul(char const *nptr, char **endptr, int base);

/*@ requires \valid_read(nptr);
    requires \separated(nptr, endptr);
    requires base ≡ 0 ∨ (2 ≤ base ≤ 36);
    assigns \result, *endptr;
    assigns \result
      \from (indirect: nptr), (indirect: *(nptr + (0 ..))), (indirect: base);
    assigns *endptr
      \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
            (indirect: base);
    
    behavior null_endptr:
      assumes endptr ≡ \null;
      assigns \result;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
    
    behavior nonnull_endptr:
      assumes endptr ≢ \null;
      requires \valid(endptr);
      ensures \initialized(\old(endptr));
      ensures \valid_read(\old(endptr));
      ensures \subset(*\old(endptr), \old(nptr) + (0 ..));
      assigns \result, *endptr;
      assigns \result
        \from (indirect: nptr), (indirect: *(nptr + (0 ..))),
              (indirect: base);
      assigns *endptr
        \from nptr, (indirect: *(nptr + (0 ..))), (indirect: endptr),
              (indirect: base);
    
    complete behaviors nonnull_endptr, null_endptr;
    disjoint behaviors nonnull_endptr, null_endptr;
 */
extern unsigned long long strtoull(char const *nptr, char **endptr, int base);

/*@ ghost
  int __fc_random_counter __attribute__((__unused__, __FRAMA_C_MODEL__)); */
unsigned long const __fc_rand_max = (unsigned long)32767;
/*@ ensures 0 ≤ \result ≤ __fc_rand_max;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
extern int rand(void);

/*@ ensures 0 ≤ \result < 2147483648;
    assigns \result, __fc_random_counter;
    assigns \result \from __fc_random_counter;
    assigns __fc_random_counter \from __fc_random_counter;
 */
extern long lrand48(void);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srand48(long seed);

/*@ assigns __fc_random_counter;
    assigns __fc_random_counter \from seed; */
extern void srand(unsigned int seed);

/*@ ghost extern int __fc_heap_status __attribute__((__FRAMA_C_MODEL__)); */

/*@
axiomatic dynamic_allocation {
  predicate is_allocable{L}(ℤ n) 
    reads __fc_heap_status;
  
  axiom never_allocable{L}:
    ∀ ℤ i; i < 0 ∨ i > 4294967295U ⇒ ¬is_allocable(i);
  
  }

*/
void *calloc(size_t nmemb, size_t size);

void *malloc(size_t size);

void free(void *p);

/*@ requires ptr ≡ \null ∨ \freeable(ptr);
    assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from __fc_heap_status;
    assigns \result \from size, ptr, __fc_heap_status;
    frees ptr;
    allocates \result;
    
    behavior alloc:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \result;
    
    behavior dealloc:
      assumes ptr ≢ \null;
      assumes is_allocable(size);
      requires \freeable(ptr);
      ensures \allocable(\old(ptr));
      ensures \result ≡ \null ∨ \freeable(\result);
      frees ptr;
    
    behavior fail:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from size, __fc_heap_status;
      allocates \nothing;
    
    complete behaviors fail, dealloc, alloc;
    disjoint behaviors alloc, fail;
    disjoint behaviors dealloc, fail;
 */
extern void *realloc(void *ptr, size_t size);

/*@ ensures \false;
    assigns \nothing; */
extern void abort(void);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int atexit(void (*func)(void));

/*@ assigns \result;
    assigns \result \from \nothing; */
extern int at_quick_exit(void (*func)(void));

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void exit(int status);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void _Exit(int status);

/*@ requires \valid_read(name);
    ensures \result ≡ \null ∨ \valid(\result);
    assigns \result;
    assigns \result \from (indirect: name), *(name + (0 ..));
 */
extern char *getenv(char const *name);

/*@ ensures \false;
    assigns \nothing; */
extern  __attribute__((__noreturn__)) void quick_exit(int status);

/*@ requires \valid_read(command);
    assigns \result;
    assigns \result
      \from (indirect: command), (indirect: *(command + (0 ..)));
 */
extern int system(char const *command);

/*@ requires \valid_function(compar);
    assigns *((char *)\result + (0 ..));
    assigns *((char *)\result + (0 ..))
      \from (indirect: key), *((char *)key + (0 ..)), (indirect: base),
            *((char *)base + (0 ..)), (indirect: nmemb), (indirect: size),
            (indirect: compar), (indirect: *compar);
 */
extern void *bsearch(void const *key, void const *base, size_t nmemb,
                     size_t size, int (*compar)(void const *, void const *));

/*@ requires \valid_function(compar);
    assigns *((char *)base + (0 ..));
    assigns *((char *)base + (0 ..))
      \from (indirect: base), *((char *)base + (0 ..)), (indirect: nmemb),
            (indirect: size), (indirect: compar), (indirect: *compar);
 */
extern void qsort(void *base, size_t nmemb, size_t size,
                  int (*compar)(void const *, void const *));

int abs(int i);

/*@ requires abs_representable: (long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long labs(long j);

/*@ requires abs_representable: (long long)(-j) ≡ -j;
    assigns \result;
    assigns \result \from j;
 */
extern long long llabs(long long j);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern div_t div(int numer, int denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern ldiv_t ldiv(long numer, long denom);

/*@ assigns \result;
    assigns \result \from numer, denom; */
extern lldiv_t lldiv(long long numer, long long denom);

/*@ ghost int __fc_mblen_state; */
/*@ assigns \result, __fc_mblen_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
    assigns __fc_mblen_state
      \from (indirect: s), (indirect: *(s + (0 ..))), (indirect: n),
            __fc_mblen_state;
 */
extern int mblen(char const *s, size_t n);

/*@ ghost int __fc_mbtowc_state; */
/*@ requires \separated(pwc, s);
    ensures \result ≤ \old(n);
    assigns \result, *(pwc + (0 .. \result - 1)), __fc_mbtowc_state;
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n),
            __fc_mbtowc_state;
    assigns *(pwc + (0 .. \result - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
    assigns __fc_mbtowc_state
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n),
            __fc_mbtowc_state;
 */
extern int mbtowc(wchar_t *pwc, char const *s, size_t n);

/*@ ghost int __fc_wctomb_state; */
/*@ assigns \result, *(s + (0 ..)), __fc_wctomb_state;
    assigns \result \from (indirect: wc), __fc_wctomb_state;
    assigns *(s + (0 ..)) \from wc, __fc_wctomb_state;
    assigns __fc_wctomb_state \from wc, __fc_wctomb_state;
 */
extern int wctomb(char *s, wchar_t wc);

/*@ requires \separated(pwcs, s);
    assigns \result, *(pwcs + (0 .. n - 1));
    assigns \result
      \from (indirect: s), (indirect: *(s + (0 .. n - 1))), (indirect: n);
    assigns *(pwcs + (0 .. n - 1))
      \from (indirect: s), *(s + (0 .. n - 1)), (indirect: n);
 */
extern size_t mbstowcs(wchar_t *pwcs, char const *s, size_t n);

/*@ requires \separated(s, pwcs);
    assigns \result, *(s + (0 .. n - 1));
    assigns \result
      \from (indirect: pwcs), (indirect: *(pwcs + (0 .. n - 1))),
            (indirect: n);
    assigns *(s + (0 .. n - 1))
      \from (indirect: pwcs), *(pwcs + (0 .. n - 1)), (indirect: n);
 */
extern size_t wcstombs(char *s, wchar_t const *pwcs, size_t n);

/*@ requires abs_representable: (int)(-i) ≡ -i;
    assigns \result;
    assigns \result \from i;
 */
int abs(int i)
{
  int __retres;
  if (i < 0) {
    __retres = - i;
    goto return_label;
  }
  __retres = i;
  return_label: return __retres;
}

/*@ requires \valid_read(p);
    assigns \result;
    assigns \result \from (indirect: p), (indirect: *(p + (0 ..)));
 */
int atoi(char const *p)
{
  int __retres;
  int n;
  int c;
  int tmp_1;
  int tmp_3;
  int neg = 0;
  unsigned char *up = (unsigned char *)p;
  c = (int)*up;
  tmp_1 = isdigit(c);
  if (! tmp_1) {
    int tmp_0;
    while (1) {
      int tmp;
      tmp = isspace(c);
      if (! tmp) break;
      up ++;
      c = (int)*up;
    }
    switch (c) {
      case '-': neg ++;
      case '+': up ++;
                c = (int)*up;
    }
    tmp_0 = isdigit(c);
    if (! tmp_0) {
      __retres = 0;
      goto return_label;
    }
  }
  n = '0' - c;
  while (1) {
    int tmp_2;
    up ++;
    c = (int)*up;
    tmp_2 = isdigit(c);
    if (! tmp_2) break;
    n *= 10;
    n += '0' - c;
  }
  if (neg) tmp_3 = n; else tmp_3 = - n;
  __retres = tmp_3;
  return_label: return __retres;
}

/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status \from size, __fc_heap_status;
    assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(size);
      ensures \fresh{Old, Here}(\result,\old(size));
      assigns __fc_heap_status, \result;
      assigns __fc_heap_status \from size, __fc_heap_status;
      assigns \result \from (indirect: size), (indirect: __fc_heap_status);
    
    behavior no_allocation:
      assumes ¬is_allocable(size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *malloc(size_t size)
{
  void *tmp;
  tmp = Frama_C_malloc_fresh(size);
  return tmp;
}

extern void Frama_C_free(void *base);

/*@ assigns __fc_heap_status;
    assigns __fc_heap_status \from __fc_heap_status;
    frees p;
    
    behavior deallocation:
      assumes p ≢ \null;
      requires freeable: \freeable(p);
      ensures \allocable(\old(p));
      assigns __fc_heap_status;
      assigns __fc_heap_status \from __fc_heap_status;
    
    behavior no_deallocation:
      assumes p ≡ \null;
      assigns \nothing;
      allocates \nothing;
    
    complete behaviors no_deallocation, deallocation;
    disjoint behaviors no_deallocation, deallocation;
 */
void free(void *p)
{
  if (p) Frama_C_free(p);
  return;
}

/*@ assigns __fc_heap_status, \result;
    assigns __fc_heap_status
      \from (indirect: nmemb), (indirect: size), __fc_heap_status;
    assigns \result
      \from (indirect: nmemb), (indirect: size), (indirect: __fc_heap_status);
    allocates \result;
    
    behavior allocation:
      assumes is_allocable(nmemb * size);
      ensures \fresh{Old, Here}(\result,\old(nmemb) * \old(size));
      ensures
        \initialized((char *)\result + (0 .. \old(nmemb) * \old(size) - 1));
      ensures
        \subset(*((char *)\result + (0 .. \old(nmemb) * \old(size) - 1)),
               {0});
    
    behavior no_allocation:
      assumes ¬is_allocable(nmemb * size);
      ensures \result ≡ \null;
      assigns \result;
      assigns \result \from \nothing;
      allocates \nothing;
    
    complete behaviors no_allocation, allocation;
    disjoint behaviors no_allocation, allocation;
 */
void *calloc(size_t nmemb, size_t size)
{
  void *__retres;
  size_t l = nmemb * size;
  if (size != (size_t)0) 
    if (l / size != nmemb) {
      __retres = (void *)0;
      goto return_label;
    }
  char *p = malloc(l);
  if (p) Frama_C_memset((void *)p,0,l);
  __retres = (void *)p;
  return_label: return __retres;
}

int memcmp(void const *s1, void const *s2, size_t n);

void *memchr(void const *s, int c, size_t n);

void *memcpy(void *dest, void const *src, size_t n);

void *memmove(void *dest, void const *src, size_t n);

void *memset(void *s, int c, size_t n);

size_t strlen(char const *s);

/*@ requires valid_string_src: valid_read_string(s);
    ensures \result ≡ strlen(\old(s)) ∨ \result ≡ \old(n);
    assigns \result;
    assigns \result \from *(s + (0 ..));
 */
extern size_t strnlen(char const *s, size_t n);

int strcmp(char const *s1, char const *s2);

int strncmp(char const *s1, char const *s2, size_t n);

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    assigns \result;
    assigns \result \from *(s1 + (0 ..)), *(s2 + (0 ..));
 */
extern int strcoll(char const *s1, char const *s2);

char *strchr(char const *s, int c);

char *strrchr(char const *s, int c);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_reject: valid_read_string(reject);
    ensures 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(reject + (0 ..));
 */
extern size_t strcspn(char const *s, char const *reject);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures 0 ≤ \result ≤ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..)), *(accept + (0 ..));
 */
extern size_t strspn(char const *s, char const *accept);

/*@ requires valid_string_src: valid_read_string(s);
    requires valid_string_accept: valid_read_string(accept);
    ensures
      \result ≡ (char *)0 ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(accept + (0 ..));
 */
extern char *strpbrk(char const *s, char const *accept);

char *strstr(char const *haystack, char const *needle);

/*@ requires valid_string_src: valid_string_or_null(s);
    requires valid_string_delim: valid_read_string(delim);
    ensures
      \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), *(delim + (0 ..));
 */
extern char *strtok(char *s, char const *delim);

/*@ requires valid_string_src: \valid(stringp) ∧ valid_string(*stringp);
    requires valid_string_delim: valid_read_string(delim);
    assigns *stringp, \result;
    assigns *stringp \from *(delim + (..)), *(*(stringp + (..)));
    assigns \result \from *(delim + (..)), *(*(stringp + (..)));
 */
extern char *strsep(char **stringp, char const *delim);

char *strerror(int errnum);

char *strcpy(char *dest, char const *src);

char *strncpy(char *dest, char const *src, size_t n);

char *strcat(char *dest, char const *src);

char *strncat(char *dest, char const *src, size_t n);

/*@ requires valid_dest: \valid(dest + (0 .. n - 1));
    requires valid_string_src: valid_read_string(src);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 ..)), n;
    assigns \result \from dest;
 */
extern size_t strxfrm(char *dest, char const *src, size_t n);

char *strdup(char const *s);

char *strndup(char const *s, size_t n);

/*@ requires \valid((char *)s + (0 .. n - 1));
    ensures \subset(*((char *)\old(s) + (0 .. \old(n) - 1)), {0});
    assigns *((char *)s + (0 .. n - 1));
    assigns *((char *)s + (0 .. n - 1)) \from \nothing;
 */
extern void bzero(void *s, size_t n);

int strcasecmp(char const *s1, char const *s2);

/*@ requires valid_dst: \valid((char *)dest + (0 .. n - 1));
    requires valid_src: \valid_read((char *)src + (0 .. n - 1));
    requires
      \separated((char *)dest + (0 .. n - 1), (char *)src + (0 .. n - 1));
    ensures
      memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memcpy(void *dest, void const *src, size_t n)
{
  void *__retres;
  char *res = (char *)dest;
  {
    size_t i = (unsigned int)0;
    while (i < n) {
      *((char *)dest + i) = *((char *)src + i);
      i += (size_t)1;
    }
  }
  __retres = (void *)res;
  return __retres;
}

/*@ assigns \result;
    assigns \result \from (indirect: p), (indirect: q), (indirect: n);
    
    behavior separated:
      assumes \separated(p + (0 .. n - 1), q + (0 .. n - 1));
      ensures \result ≡ 0;
    
    behavior not_separated_lt:
      assumes ¬\separated(p + (0 .. n - 1), q + (0 .. n - 1));
      assumes p ≤ q < p + n;
      ensures \result ≡ -1;
    
    behavior not_separated_gt:
      assumes ¬\separated(p + (0 .. n - 1), q + (0 .. n - 1));
      assumes q < p ≤ q + n;
      ensures \result ≡ 1;
    
    complete behaviors not_separated_gt, not_separated_lt, separated;
    disjoint behaviors not_separated_gt, not_separated_lt, separated;
 */
static int memoverlap(char const *p, char const *q, size_t n);

/*@ requires valid_dst: \valid((char *)dest + (0 .. n - 1));
    requires valid_src: \valid_read((char *)src + (0 .. n - 1));
    ensures
      memcmp{Post, Pre}((char *)\old(dest), (char *)\old(src), \old(n)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *((char *)dest + (0 .. n - 1)), \result;
    assigns *((char *)dest + (0 .. n - 1))
      \from *((char *)src + (0 .. n - 1));
    assigns \result \from dest;
 */
void *memmove(void *dest, void const *src, size_t n)
{
  void *__retres;
  int tmp_0;
  if (n == (size_t)0) {
    __retres = dest;
    goto return_label;
  }
  char *s = (char *)src;
  tmp_0 = memoverlap((char const *)dest,(char const *)src,n);
  if (tmp_0 <= 0) {
    void *tmp;
    tmp = memcpy(dest,src,n);
    __retres = tmp;
    goto return_label;
  }
  else {
    char *d = (char *)dest;
    {
      size_t i = n - (size_t)1;
      while (i > (size_t)0) {
        *(d + i) = *(s + i);
        i -= (size_t)1;
      }
    }
    *(d + 0) = *(s + 0);
    __retres = dest;
    goto return_label;
  }
  return_label: return __retres;
}

/*@ requires valid_string_src: valid_read_string(s);
    ensures \result ≡ strlen(\old(s));
    assigns \result;
    assigns \result \from *(s + (0 ..));
 */
size_t strlen(char const *s)
{
  size_t i;
  i = (unsigned int)0;
  while ((int)*(s + i) != 0) i += (size_t)1;
  return i;
}

/*@ requires \valid((char *)s + (0 .. n - 1));
    ensures memset((char *)\old(s), \old(c), \old(n)) ≡ \true;
    ensures \result ≡ \old(s);
    assigns *((char *)s + (0 .. n - 1)), \result;
    assigns *((char *)s + (0 .. n - 1)) \from c;
    assigns \result \from s;
 */
void *memset(void *s, int c, size_t n)
{
  unsigned char *p = (unsigned char *)s;
  {
    size_t i = (unsigned int)0;
    while (i < n) {
      *(p + i) = (unsigned char)c;
      i += (size_t)1;
    }
  }
  return s;
}

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures \result ≡ strcmp(\old(s1), \old(s2));
    assigns \result;
    assigns \result \from *(s1 + (0 ..)), *(s2 + (0 ..));
 */
int strcmp(char const *s1, char const *s2)
{
  int __retres;
  size_t i;
  i = (unsigned int)0;
  while ((int)*(s1 + i) == (int)*(s2 + i)) {
    if ((int)*(s1 + i) == 0) {
      __retres = 0;
      goto return_label;
    }
    i += (size_t)1;
  }
  __retres = (int)*((unsigned char *)s1 + i) - (int)*((unsigned char *)s2 + i);
  return_label: return __retres;
}

/*@ requires valid_string_s1: valid_read_string(s1);
    requires valid_string_s2: valid_read_string(s2);
    ensures \result ≡ strncmp(\old(s1), \old(s2), \old(n));
    assigns \result;
    assigns \result \from *(s1 + (0 .. n - 1)), *(s2 + (0 .. n - 1));
 */
int strncmp(char const *s1, char const *s2, size_t n)
{
  int __retres;
  {
    size_t i = (unsigned int)0;
    while (i < n) {
      if ((int)*(s1 + i) != (int)*(s2 + i)) {
        __retres = (int)*((unsigned char *)s1 + i) - (int)*((unsigned char *)s2 + i);
        goto return_label;
      }
      if ((int)*(s1 + i) == 0) {
        __retres = 0;
        goto return_label;
      }
      i += (size_t)1;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

/*@ requires \valid_read((char *)s1 + (0 .. n - 1));
    requires \valid_read((char *)s2 + (0 .. n - 1));
    ensures
      \result ≡
      memcmp{Pre, Pre}((char *)\old(s1), (char *)\old(s2), \old(n));
    assigns \result;
    assigns \result
      \from *((char *)s1 + (0 .. n - 1)), *((char *)s2 + (0 .. n - 1));
 */
int memcmp(void const *s1, void const *s2, size_t n)
{
  int __retres;
  unsigned char const *p1;
  unsigned char const *p2;
  p1 = (unsigned char const *)s1;
  p2 = (unsigned char const *)s2;
  {
    size_t i = (unsigned int)0;
    while (i < n) {
      if ((int)*(p1 + i) != (int)*(p2 + i)) {
        __retres = (int)*(p1 + i) - (int)*(p2 + i);
        goto return_label;
      }
      i += (size_t)1;
    }
  }
  __retres = 0;
  return_label: return __retres;
}

static int char_equal_ignore_case(char c1, char c2)
{
  int __retres;
  if ((int)c1 >= 'A') 
    if ((int)c1 <= 'Z') c1 = (char)((int)c1 - ('A' - 'a'));
  if ((int)c2 >= 'A') 
    if ((int)c2 <= 'Z') c2 = (char)((int)c2 - ('A' - 'a'));
  if ((int)c1 == (int)c2) {
    __retres = 0;
    goto return_label;
  }
  else {
    __retres = (int)((unsigned char)c2) - (int)((unsigned char)c1);
    goto return_label;
  }
  return_label: return __retres;
}

int strcasecmp(char const *s1, char const *s2)
{
  int __retres;
  size_t i;
  i = (unsigned int)0;
  while (1) {
    if ((int)*(s1 + i) != 0) {
      if (! ((int)*(s2 + i) != 0)) break;
    }
    else break;
    {
      int res = char_equal_ignore_case(*(s1 + i),*(s2 + i));
      if (res != 0) {
        __retres = res;
        goto return_label;
      }
    }
    i += (size_t)1;
  }
  if ((int)*(s1 + i) == 0) {
    if ((int)*(s2 + i) == 0) {
      __retres = 0;
      goto return_label;
    }
    else goto _LAND;
  }
  else {
    _LAND: ;
    if ((int)*(s1 + i) == 0) {
      __retres = -1;
      goto return_label;
    }
    else {
      __retres = 1;
      goto return_label;
    }
  }
  return_label: return __retres;
}

/*@ requires valid_string_src: valid_read_string(src);
    requires valid_string_dst: valid_string(dest);
    requires room_string: \valid(dest + (0 .. strlen(dest) + strlen(src)));
    ensures strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
    ensures \result ≡ \old(dest);
    assigns *(dest +
              (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
            \result;
    assigns
    *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcat(char *dest, char const *src)
{
  size_t i;
  size_t n = strlen((char const *)dest);
  i = (unsigned int)0;
  while ((int)*(src + i) != 0) {
    *(dest + (n + i)) = *(src + i);
    i += (size_t)1;
  }
  *(dest + (n + i)) = (char)0;
  return dest;
}

/*@ requires
      valid_string_src:
        valid_read_string(src) ∨ \valid_read(src + (0 .. n - 1));
    requires valid_string_dst: valid_string(dest);
    requires room_string: \valid(dest + (strlen(dest) .. strlen(dest) + n));
    ensures \result ≡ \old(dest);
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)), \result;
    assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
      \from *(src + (0 .. n));
    assigns \result \from dest;
    
    behavior complete:
      assumes valid_read_string(src) ∧ strlen(src) ≤ n;
      ensures strlen(\old(dest)) ≡ \old(strlen(dest) + strlen(src));
      assigns *(dest +
                (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src))),
              \result;
      assigns
      *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + strlen{Old}(src)))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
    
    behavior partial:
      assumes ¬(valid_read_string(src) ∧ strlen(src) ≤ n);
      ensures strlen(\old(dest)) ≡ \old(strlen(dest)) + \old(n);
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n)),
              \result;
      assigns *(dest + (strlen{Old}(dest) .. strlen{Old}(dest) + n))
        \from *(src + (0 .. strlen{Old}(src)));
      assigns \result \from dest;
 */
char *strncat(char *dest, char const *src, size_t n)
{
  size_t i;
  size_t dest_len = strlen((char const *)dest);
  i = (unsigned int)0;
  while (i < n) {
    if ((int)*(src + i) == 0) break;
    *(dest + (dest_len + i)) = *(src + i);
    i += (size_t)1;
  }
  *(dest + (dest_len + i)) = (char)0;
  return dest;
}

/*@ requires valid_string_src: valid_read_string(src);
    requires room_string: \valid(dest + (0 .. strlen(src)));
    ensures strcmp(\old(dest), \old(src)) ≡ 0;
    ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. strlen{Old}(src))), \result;
    assigns *(dest + (0 .. strlen{Old}(src)))
      \from *(src + (0 .. strlen{Old}(src)));
    assigns \result \from dest;
 */
char *strcpy(char *dest, char const *src)
{
  size_t i;
  i = (unsigned int)0;
  while ((int)*(src + i) != 0) {
    *(dest + i) = *(src + i);
    i += (size_t)1;
  }
  *(dest + i) = (char)0;
  return dest;
}

/*@ requires valid_string_src: valid_read_string(src);
    requires room_nstring: \valid(dest + (0 .. n - 1));
    ensures \result ≡ \old(dest);
    ensures \initialized(\old(dest) + (0 .. \old(n) - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1)) \from *(src + (0 .. n - 1));
    assigns \result \from dest;
    
    behavior complete:
      assumes strlen(src) < n;
      ensures strcmp(\old(dest), \old(src)) ≡ 0;
    
    behavior partial:
      assumes n ≤ strlen(src);
      ensures memcmp{Post, Post}(\old(dest), \old(src), \old(n)) ≡ 0;
 */
char *strncpy(char *dest, char const *src, size_t n)
{
  size_t i;
  i = (unsigned int)0;
  while (i < n) {
    *(dest + i) = *(src + i);
    if ((int)*(src + i) == 0) break;
    i += (size_t)1;
  }
  while (i < n) {
    *(dest + i) = (char)0;
    i += (size_t)1;
  }
  return dest;
}

/*@ requires valid_string_src: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes strchr(s, c) ≡ \true;
      ensures (int)*\result ≡ \old(c);
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures \old(s) ≤ \result < \old(s) + strlen(\old(s));
      ensures valid_read_string(\result);
      ensures ∀ char *p; \old(s) ≤ p < \result ⇒ (int)*p ≢ \old(c);
    
    behavior not_found:
      assumes ¬(strchr(s, c) ≡ \true);
      ensures \result ≡ \null;
    
    behavior default:
      ensures
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strchr(char const *s, int c)
{
  char *__retres;
  size_t i;
  char ch = (char)c;
  i = (unsigned int)0;
  while ((int)*(s + i) != (int)ch) {
    if ((int)*(s + i) == 0) {
      __retres = (char *)0;
      goto return_label;
    }
    i += (size_t)1;
  }
  __retres = (char *)(s + i);
  return_label: return __retres;
}

/*@ requires valid_string_src: valid_read_string(s);
    assigns \result;
    assigns \result \from s, *(s + (0 ..)), c;
    
    behavior found:
      assumes strchr(s, c) ≡ \true;
      ensures (int)*\result ≡ \old(c);
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures valid_read_string(\result);
    
    behavior not_found:
      assumes ¬(strchr(s, c) ≡ \true);
      ensures \result ≡ \null;
    
    behavior default:
      ensures
        \result ≡ \null ∨ \base_addr(\result) ≡ \base_addr(\old(s));
 */
char *strrchr(char const *s, int c)
{
  char *__retres;
  char ch = (char)c;
  {
    size_t tmp;
    tmp = strlen(s);
    size_t i = tmp + (size_t)1;
    while (i > (size_t)0) {
      if ((int)*(s + (i - (size_t)1)) == (int)ch) {
        __retres = (char *)(s + (i - (size_t)1));
        goto return_label;
      }
      i -= (size_t)1;
    }
  }
  __retres = (char *)0;
  return_label: return __retres;
}

/*@ requires \valid_read((unsigned char *)s + (0 .. n - 1));
    assigns \result;
    assigns \result \from s, c, *((unsigned char *)s + (0 .. n - 1));
    
    behavior found:
      assumes memchr((char *)s, c, n) ≡ \true;
      ensures \base_addr(\result) ≡ \base_addr(\old(s));
      ensures (int)*((char *)\result) ≡ \old(c);
      ensures
        ∀ ℤ i;
          0 ≤ i < \old(n) ⇒
          *((unsigned char *)\old(s) + i) ≡ \old(c) ⇒
          \result ≤ \old(s) + i;
    
    behavior not_found:
      assumes ¬(memchr((char *)s, c, n) ≡ \true);
      ensures \result ≡ \null;
 */
void *memchr(void const *s, int c, size_t n)
{
  void *__retres;
  unsigned char ch = (unsigned char)c;
  unsigned char const *ss = (unsigned char const *)s;
  {
    size_t i = (unsigned int)0;
    while (i < n) {
      if ((int)*(ss + i) == (int)ch) {
        __retres = (void *)(ss + i);
        goto return_label;
      }
      i += (size_t)1;
    }
  }
  __retres = (void *)0;
  return_label: return __retres;
}

void *memrchr(void const *s, int c, size_t n)
{
  void *__retres;
  unsigned char ch = (unsigned char)c;
  unsigned char const *ss = (unsigned char const *)s;
  {
    size_t i = n;
    while (i > (size_t)0) {
      if ((int)*(ss + (i - (size_t)1)) == (int)ch) {
        __retres = (void *)(ss + (i - (size_t)1));
        goto return_label;
      }
      i -= (size_t)1;
    }
  }
  __retres = (void *)0;
  return_label: return __retres;
}

/*@ requires valid_string_haystack: valid_read_string(haystack);
    requires valid_string_needle: valid_read_string(needle);
    ensures
      \result ≡ (char *)0 ∨
      (\subset(\result, \old(haystack) + (0 ..)) ∧ \valid_read(\result) ∧
       memcmp{Pre, Pre}(\result, \old(needle), strlen(\old(needle))) ≡ 0);
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
char *strstr(char const *haystack, char const *needle)
{
  char *__retres;
  if ((int)*(needle + 0) == 0) {
    __retres = (char *)haystack;
    goto return_label;
  }
  {
    size_t i = (unsigned int)0;
    while ((int)*(haystack + i) != 0) {
      {
        size_t j;
        j = (unsigned int)0;
        while ((int)*(haystack + (i + j)) != 0) {
          if ((int)*(haystack + (i + j)) != (int)*(needle + j)) break;
          j += (size_t)1;
        }
        if ((int)*(needle + j) == 0) {
          __retres = (char *)(haystack + i);
          goto return_label;
        }
      }
      i += (size_t)1;
    }
  }
  __retres = (char *)0;
  return_label: return __retres;
}

/*@ ensures valid_read_string(\result);
    assigns \result;
    assigns \result \from errnum;
 */
char *strerror(int errnum)
{
  char *__retres;
  __retres = (char *)"strerror message by Frama-C";
  return __retres;
}

/*@ requires valid_string_src: valid_read_string(s);
    ensures
      \valid(\result + (0 .. strlen(\old(s)))) ∧
      strcmp(\result, \old(s)) ≡ 0;
    assigns \nothing;
 */
char *strdup(char const *s)
{
  size_t tmp;
  tmp = strlen(s);
  size_t l = tmp + (size_t)1;
  char *p = malloc(l);
  memcpy((void *)p,(void const *)s,l);
  return p;
}

/*@ requires valid_string_src: valid_read_string(s);
    ensures
      \valid(\result + (0 .. minimum(strlen(\old(s)), \old(n)))) ∧
      valid_string(\result) ∧ strlen(\result) ≤ \old(n) ∧
      strncmp(\result, \old(s), \old(n)) ≡ 0;
    assigns \nothing;
 */
char *strndup(char const *s, size_t n)
{
  size_t l;
  l = (unsigned int)0;
  while (l < n) {
    if ((int)*(s + l) == 0) break;
    l += (size_t)1;
  }
  char *p = malloc(l + (size_t)1);
  memcpy((void *)p,(void const *)s,l);
  *(p + l) = (char)0;
  return p;
}

/*@ ensures
      \result ≡ \null ∨ \subset(\result, \old(s) + (0 .. \old(n) - 1));
    assigns \result;
    assigns \result
      \from s, (indirect: *(s + (0 .. n - 1))), (indirect: c), (indirect: n);
 */
extern wchar_t *wmemchr(wchar_t const *s, wchar_t c, size_t n);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wmemcmp(wchar_t const *s1, wchar_t const *s2, size_t n);

wchar_t *wmemcpy(wchar_t *region1, wchar_t const *region2, size_t n);

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
extern wchar_t *wmemmove(wchar_t *dest, wchar_t const *src, size_t n);

wchar_t *wmemset(wchar_t *dest, wchar_t val, size_t len);

wchar_t *wcscat(wchar_t *s1, wchar_t const *s2);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: wc);
 */
extern wchar_t *wcschr(wchar_t const *wcs, wchar_t wc);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 ..))), (indirect: *(s2 + (0 ..)));
 */
extern int wcscmp(wchar_t const *s1, wchar_t const *s2);

wchar_t *wcscpy(wchar_t *s1, wchar_t const *s2);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcscspn(wchar_t const *wcs, wchar_t const *accept);

/*@ assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 ..))), (indirect: *(src + (0 .. n - 1))),
            (indirect: n);
 */
extern size_t wcslcat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ requires \separated(dest + (0 .. n - 1), src + (0 .. n - 1));
    assigns *(dest + (0 .. n - 1)), \result;
    assigns *(dest + (0 .. n - 1))
      \from *(src + (0 .. n - 1)), (indirect: src), (indirect: n);
    assigns \result
      \from (indirect: *(dest + (0 .. n - 1))), (indirect: dest),
            (indirect: *(src + (0 .. n - 1))), (indirect: src), (indirect: n);
 */
extern size_t wcslcpy(wchar_t *dest, wchar_t const *src, size_t n);

size_t wcslen(wchar_t const *str);

wchar_t *wcsncat(wchar_t *dest, wchar_t const *src, size_t n);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(s1 + (0 .. n - 1))),
            (indirect: *(s2 + (0 .. n - 1))), (indirect: n);
 */
extern int wcsncmp(wchar_t const *s1, wchar_t const *s2, size_t n);

wchar_t *wcsncpy(wchar_t *s1, wchar_t const *s2, size_t n);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result
      \from wcs, (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern wchar_t *wcspbrk(wchar_t const *wcs, wchar_t const *accept);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(wcs) + (0 ..));
    assigns \result;
    assigns \result \from wcs, (indirect: *(wcs + (0 ..))), (indirect: wc);
 */
extern wchar_t *wcsrchr(wchar_t const *wcs, wchar_t wc);

/*@ assigns \result;
    assigns \result
      \from (indirect: *(wcs + (0 ..))), (indirect: *(accept + (0 ..)));
 */
extern size_t wcsspn(wchar_t const *wcs, wchar_t const *accept);

/*@ ensures \result ≡ \null ∨ \subset(\result, \old(haystack) + (0 ..));
    assigns \result;
    assigns \result
      \from haystack, (indirect: *(haystack + (0 ..))),
            (indirect: *(needle + (0 ..)));
 */
extern wchar_t *wcsstr(wchar_t const *haystack, wchar_t const *needle);

/*@ requires \separated(region1 + (0 .. n - 1), region2 + (0 .. n - 1));
    ensures \result ≡ \old(region1);
    assigns *(region1 + (0 .. n - 1)), \result;
    assigns *(region1 + (0 .. n - 1))
      \from *(region2 + (0 .. n - 1)), (indirect: region2), (indirect: n);
    assigns \result \from region1;
 */
wchar_t *wmemcpy(wchar_t *region1, wchar_t const *region2, size_t n)
{
  wchar_t const *first = region2;
  wchar_t const *last = region2 + n;
  wchar_t *result = region1;
  wchar_t *dest = result;
  while (first != last) {
    wchar_t *tmp;
    wchar_t const *tmp_0;
    tmp = dest;
    dest ++;
    tmp_0 = first;
    first ++;
    *tmp = *tmp_0;
  }
  return result;
}

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 .. len - 1)), \result;
    assigns *(dest + (0 .. len - 1)) \from val, (indirect: len);
    assigns \result \from dest;
 */
wchar_t *wmemset(wchar_t *dest, wchar_t val, size_t len)
{
  wchar_t *ptr = dest;
  while (1) {
    size_t tmp_0;
    wchar_t *tmp;
    tmp_0 = len;
    len -= (size_t)1;
    ;
    if (! (tmp_0 > (size_t)0)) break;
    tmp = ptr;
    ptr ++;
    *tmp = val;
  }
  return dest;
}

/*@ ensures \result ≡ \old(s1);
    assigns *(s1 + (0 ..)), \result;
    assigns *(s1 + (0 ..))
      \from *(s2 + (0 ..)), (indirect: s2), *(s1 + (0 ..)), (indirect: s1);
    assigns \result \from s1;
 */
wchar_t *wcscpy(wchar_t *s1, wchar_t const *s2)
{
  wchar_t *os1 = s1;
  while (1) {
    wchar_t *tmp;
    wchar_t const *tmp_1;
    wchar_t tmp_0;
    tmp = s1;
    s1 ++;
    tmp_1 = s2;
    s2 ++;
    tmp_0 = *tmp_1;
    *tmp = tmp_0;
    if (! tmp_0) break;
  }
  return os1;
}

/*@ assigns \result;
    assigns \result \from (indirect: *(str + (0 ..))); */
size_t wcslen(wchar_t const *str)
{
  size_t __retres;
  wchar_t const *s = str;
  s = str;
  while (*s) s ++;
  __retres = (unsigned int)(s - str);
  return __retres;
}

/*@ requires \separated(s1 + (0 .. n - 1), s2 + (0 .. n - 1));
    ensures \result ≡ \old(s1);
    assigns *(s1 + (0 .. n - 1)), \result;
    assigns *(s1 + (0 .. n - 1))
      \from *(s2 + (0 .. n - 1)), (indirect: s2), (indirect: n);
    assigns \result \from s1;
 */
wchar_t *wcsncpy(wchar_t *s1, wchar_t const *s2, size_t n)
{
  wchar_t *os1 = s1;
  n += (size_t)1;
  while (1) {
    n -= (size_t)1;
    if (n != (size_t)0) {
      wchar_t *tmp;
      wchar_t const *tmp_1;
      wchar_t tmp_0;
      tmp = s1;
      s1 ++;
      tmp_1 = s2;
      s2 ++;
      tmp_0 = *tmp_1;
      *tmp = tmp_0;
      if (! (tmp_0 != 0)) break;
    }
    else break;
  }
  if (n != (size_t)0) 
    while (1) {
      wchar_t *tmp_2;
      n -= (size_t)1;
      if (! (n != (size_t)0)) break;
      tmp_2 = s1;
      s1 ++;
      *tmp_2 = 0;
    }
  return os1;
}

/*@ ensures \result ≡ \old(s1);
    assigns *(s1 + (0 ..)), \result;
    assigns *(s1 + (0 ..))
      \from *(s1 + (0 ..)), (indirect: s1), *(s2 + (0 ..)), (indirect: s2);
    assigns \result \from s1;
 */
wchar_t *wcscat(wchar_t *s1, wchar_t const *s2)
{
  wchar_t *os1 = s1;
  while (1) {
    wchar_t *tmp;
    tmp = s1;
    s1 ++;
    ;
    if (! *tmp) break;
  }
  s1 --;
  while (1) {
    wchar_t *tmp_0;
    wchar_t const *tmp_2;
    wchar_t tmp_1;
    tmp_0 = s1;
    s1 ++;
    tmp_2 = s2;
    s2 ++;
    tmp_1 = *tmp_2;
    *tmp_0 = tmp_1;
    if (! tmp_1) break;
  }
  return os1;
}

/*@ ensures \result ≡ \old(dest);
    assigns *(dest + (0 ..)), \result;
    assigns *(dest + (0 ..))
      \from *(dest + (0 ..)), (indirect: dest), *(src + (0 .. n - 1)),
            (indirect: src), (indirect: n);
    assigns \result \from dest;
 */
wchar_t *wcsncat(wchar_t *dest, wchar_t const *src, size_t n)
{
  size_t i;
  size_t dest_len = wcslen((wchar_t const *)dest);
  i = (unsigned int)0;
  while (1) {
    if (i < n) {
      if (! (*(src + i) != 0)) break;
    }
    else break;
    *(dest + (dest_len + i)) = *(src + i);
    i += (size_t)1;
  }
  *(dest + (dest_len + i)) = 0;
  return dest;
}

/*@ assigns Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern void Frama_C_update_entropy(void);

/*@ ensures \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
int Frama_C_nondet(int a, int b)
{
  int tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = a; else tmp = b;
  return tmp;
}

/*@ ensures \result ≡ \old(a) ∨ \result ≡ \old(b);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from a, b, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
void *Frama_C_nondet_ptr(void *a, void *b)
{
  void *__retres;
  int tmp;
  tmp = Frama_C_nondet((int)a,(int)b);
  __retres = (void *)tmp;
  return __retres;
}

/*@ requires min ≤ max;
    ensures \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
int Frama_C_interval(int min, int max)
{
  int r;
  int aux;
  Frama_C_update_entropy();
  aux = Frama_C_entropy_source;
  if (aux >= min) 
    if (aux <= max) r = aux; else r = min;
  else r = min;
  return r;
}

/*@ requires \is_finite(min) ∧ \is_finite(max);
    requires min ≤ max;
    ensures \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
float Frama_C_float_interval(float min, float max)
{
  float tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = min; else tmp = max;
  return tmp;
}

/*@ requires \is_finite(min) ∧ \is_finite(max);
    requires min ≤ max;
    ensures \is_finite(\result) ∧ \old(min) ≤ \result ≤ \old(max);
    assigns \result, Frama_C_entropy_source;
    assigns \result \from min, max, Frama_C_entropy_source;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
double Frama_C_double_interval(double min, double max)
{
  double tmp;
  Frama_C_update_entropy();
  if (Frama_C_entropy_source) tmp = min; else tmp = max;
  return tmp;
}

/*@ ghost struct __fc_sockfds_type __fc_sockfds[1024]; */
/*@ ghost extern int __fc_socket_counter __attribute__((__FRAMA_C_MODEL__));
*/

/*@ ghost int volatile __fc_open_sock_fds; */
/*@ requires 0 ≤ sockfd < 1024;
    ensures (0 ≤ \result < 1024) ∨ \result ≡ -1;
    assigns \result, *((char *)addr + (0 .. *addrlen - 1)),
            __fc_sockfds[sockfd];
    assigns \result \from *addr, *addrlen, __fc_sockfds[sockfd];
    assigns *((char *)addr + (0 .. *addrlen - 1))
      \from *addr, *addrlen, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from *addr, *addrlen, __fc_sockfds[sockfd];
    
    behavior addr_null:
      assumes addr ≡ \null;
      requires addrlen ≡ \null;
      assigns \result, __fc_sockfds[sockfd];
      assigns \result \from __fc_sockfds[sockfd];
      assigns __fc_sockfds[sockfd] \from __fc_sockfds[sockfd];
    
    behavior addr_not_null:
      assumes addr ≢ \null;
      requires \valid(addrlen);
      requires \valid((char *)addr + (0 .. *addrlen - 1));
      ensures \initialized((char *)\old(addr) + (0 .. *\old(addrlen) - 1));
    
    disjoint behaviors addr_not_null, addr_null;
 */
extern int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

/*@ requires 0 ≤ sockfd < 1024;
    requires \valid_read((char *)addr + (0 .. addrlen - 1));
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result \from sockfd, *addr, addrlen, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd]
      \from sockfd, *addr, addrlen, __fc_sockfds[sockfd];
 */
extern int bind(int sockfd, struct sockaddr const *addr, socklen_t addrlen);

/*@ requires 0 ≤ sockfd < 1024;
    requires \valid_read((char *)addr + (0 .. addrlen - 1));
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns __fc_sockfds[sockfd], \result;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], (indirect: sockfd), (indirect: addr),
            (indirect: *addr), (indirect: addrlen);
    assigns \result
      \from (indirect: __fc_sockfds[sockfd]), (indirect: sockfd),
            (indirect: addr), (indirect: *addr), (indirect: addrlen);
 */
extern int connect(int sockfd, struct sockaddr const *addr, socklen_t addrlen);

/*@ requires 0 ≤ sockfd < 1024;
    requires \valid(optlen);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns *((char *)optval + (0 ..)), \result, *optlen;
    assigns *((char *)optval + (0 ..))
      \from (indirect: sockfd), (indirect: level), (indirect: optname),
            (indirect: *optlen), (indirect: optval),
            (indirect: __fc_sockfds[sockfd]);
    assigns \result
      \from (indirect: sockfd), (indirect: level), (indirect: optname),
            (indirect: *optlen), (indirect: optval),
            (indirect: __fc_sockfds[sockfd]);
    assigns *optlen
      \from (indirect: sockfd), (indirect: level), (indirect: optname),
            *optlen, (indirect: optval), (indirect: __fc_sockfds[sockfd]);
    
    behavior so_error:
      assumes level ≡ 0xffff ∧ optname ≡ 0x1007;
      requires \valid(optlen);
      requires *optlen ≡ sizeof(int);
      requires \valid((int *)optval);
      assigns *((int *)optval), \result;
      assigns *((int *)optval)
        \from (indirect: sockfd), (indirect: optlen),
              (indirect: __fc_sockfds[sockfd]);
      assigns \result
        \from (indirect: sockfd), (indirect: optlen),
              (indirect: __fc_sockfds[sockfd]);
    
    behavior other_options:
      assumes ¬(level ≡ 0xffff ∧ optname ≡ 0x1007);
      requires optval ≡ \null ∨ \valid((char *)optval + (0 ..));
      assigns *((char *)optval + (0 ..)), \result, *optlen;
      assigns *((char *)optval + (0 ..))
        \from (indirect: sockfd), (indirect: level), (indirect: optname),
              (indirect: *optlen), (indirect: optval),
              (indirect: __fc_sockfds[sockfd]);
      assigns \result
        \from (indirect: sockfd), (indirect: level), (indirect: optname),
              (indirect: *optlen), (indirect: optval),
              (indirect: __fc_sockfds[sockfd]);
      assigns *optlen
        \from (indirect: sockfd), (indirect: level), (indirect: optname),
              *optlen, (indirect: optval), (indirect: __fc_sockfds[sockfd]);
    
    complete behaviors other_options, so_error;
    disjoint behaviors other_options, so_error;
 */
extern int getsockopt(int sockfd, int level, int optname, void *optval,
                      socklen_t *optlen);

/*@ requires 0 ≤ sockfd < 1024;
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result \from sockfd, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from sockfd, backlog, __fc_sockfds[sockfd];
 */
extern int listen(int sockfd, int backlog);

/*@ requires 0 ≤ sockfd < 1024;
    requires \valid((char *)buf + (0 .. len - 1));
    ensures (0 ≤ \result ≤ \old(len)) ∨ \result ≡ -1;
    ensures \initialized((char *)\old(buf) + (0 .. \result - 1));
    assigns *((char *)buf + (0 .. len - 1)), __fc_sockfds[sockfd], \result;
    assigns *((char *)buf + (0 .. len - 1))
      \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd]
      \from sockfd, len, flags, __fc_sockfds[sockfd];
    assigns \result \from sockfd, len, flags, __fc_sockfds[sockfd];
 */
extern ssize_t recv(int sockfd, void *buf, size_t len, int flags);

/*@ requires 0 ≤ sockfd < 1024;
    requires
      \valid((char *)hdr->msg_control + (0 .. hdr->msg_controllen - 1));
    requires \valid(hdr->msg_iov + (0 .. hdr->msg_iovlen - 1));
    requires
      hdr->msg_name ≡ (void *)0 ∨
      \valid((char *)hdr->msg_name + (0 .. hdr->msg_namelen - 1));
    ensures \result ≤ \old(hdr)->msg_iovlen;
    assigns *((char *)hdr->msg_name + (0 .. hdr->msg_namelen - 1)),
            hdr->msg_namelen,
            *((char *)(hdr->msg_iov + (0 .. hdr->msg_iovlen - 1))->iov_base +
              (0 ..)),
            *((char *)hdr->msg_control + (0 .. hdr->msg_controllen - 1)),
            \result, hdr->msg_controllen, hdr->msg_flags,
            __fc_sockfds[sockfd];
    assigns *((char *)hdr->msg_name + (0 .. hdr->msg_namelen - 1))
      \from __fc_sockfds[sockfd];
    assigns hdr->msg_namelen \from __fc_sockfds[sockfd];
    assigns
    *((char *)(hdr->msg_iov + (0 .. hdr->msg_iovlen - 1))->iov_base + (0 ..))
      \from __fc_sockfds[sockfd];
    assigns *((char *)hdr->msg_control + (0 .. hdr->msg_controllen - 1))
      \from __fc_sockfds[sockfd];
    assigns \result \from __fc_sockfds[sockfd];
    assigns hdr->msg_controllen \from __fc_sockfds[sockfd];
    assigns hdr->msg_flags \from __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from __fc_sockfds[sockfd];
 */
extern ssize_t recvmsg(int sockfd, struct msghdr *hdr, int flags);

/*@ requires 0 ≤ sockfd < 1024;
    requires
      optval ≡ \null ∨ \valid_read((char *)optval + (0 .. optlen - 1));
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result
      \from __fc_sockfds[sockfd], level, optname,
            *((char *)optval + (0 .. optlen - 1)), optlen;
    assigns __fc_sockfds[sockfd]
      \from __fc_sockfds[sockfd], level, optname,
            *((char *)optval + (0 .. optlen - 1)), optlen;
 */
extern int setsockopt(int sockfd, int level, int optname, void const *optval,
                      socklen_t optlen);

/*@ requires 0 ≤ sockfd < 1024;
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_sockfds[sockfd];
    assigns \result \from how, __fc_sockfds[sockfd];
    assigns __fc_sockfds[sockfd] \from how, __fc_sockfds[sockfd];
 */
extern int shutdown(int sockfd, int how);

/*@ ensures (0 ≤ \result < 1024) ∨ \result ≡ -1;
    assigns \result, __fc_socket_counter;
    assigns \result
      \from (indirect: domain), (indirect: type), (indirect: protocol),
            (indirect: __fc_socket_counter);
    assigns __fc_socket_counter
      \from (indirect: domain), (indirect: type), (indirect: protocol),
            __fc_socket_counter;
 */
extern int socket(int domain, int type, int protocol);

/*@ requires \valid(socket_vector + (0 .. 1));
    ensures \initialized(\old(socket_vector) + (0 .. 1));
    ensures \result ≡ 0 ∨ \result ≡ -1;
    ensures 0 ≤ *(\old(socket_vector) + 0) < 1024;
    ensures 0 ≤ *(\old(socket_vector) + 1) < 1024;
    assigns \result, __fc_socket_counter, *(socket_vector + (0 .. 1));
    assigns \result \from __fc_socket_counter;
    assigns __fc_socket_counter \from __fc_socket_counter;
    assigns *(socket_vector + (0 .. 1)) \from __fc_socket_counter;
 */
extern int socketpair(int domain, int type, int protocol,
                      int * /*[2]*/ socket_vector);

struct in6_addr const in6addr_any = {.s6_addr = {(unsigned char)0}};
struct in6_addr const in6addr_loopback =
  {.s6_addr = {(unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF,
               (unsigned char)0xFF}};
/*@ assigns \result;
    assigns \result \from arg; */
extern uint32_t htonl(uint32_t arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern uint16_t htons(uint16_t arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern uint32_t ntohl(uint32_t arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern uint16_t ntohs(uint16_t arg);

/*@ requires valid_read_string(arg);
    assigns \result;
    assigns \result \from (indirect: *(arg + (0 ..)));
 */
extern in_addr_t inet_addr(char const *arg);

/*@ assigns \result;
    assigns \result \from arg; */
extern char *inet_ntoa(struct in_addr arg);

/*@ assigns \result, *(dst + (0 .. size - 1));
    assigns \result \from dst, af, *((char *)src + (0 ..));
    assigns *(dst + (0 .. size - 1)) \from af, *((char *)src + (0 ..));
 */
extern char const *inet_ntop(int af, void const *src, char *dst,
                             socklen_t size);

/*@ assigns \result, *((char *)dst + (0 ..));
    assigns \result \from af, *(src + (..));
    assigns *((char *)dst + (0 ..)) \from af, *(src + (0 ..));
 */
extern int inet_pton(int af, char const *src, void *dst);

DIR __fc_opendir[512];
DIR * const __fc_p_opendir = __fc_opendir;
/*@ requires \subset(dirp, &__fc_opendir[0 .. 512 - 1]);
    ensures
      (\result ≡ 0 ∧ \old(dirp)->__fc_dir_inode ≡ \null) ∨
      \result ≡ -1;
    assigns \result, __fc_errno, *dirp;
    assigns \result \from dirp, *dirp, __fc_p_opendir;
    assigns __fc_errno \from dirp, *dirp, __fc_p_opendir;
    assigns *dirp \from dirp, *dirp, __fc_p_opendir;
 */
extern int closedir(DIR *dirp);

/*@ ensures \result ≡ \null ∨ \valid(\result);
    ensures
      \result ≢ \null ⇒ \result ≡ &__fc_opendir[\result->__fc_dir_id];
    ensures \result ≢ \null ⇒ \result->__fc_dir_inode ≢ \null;
    assigns \result, __fc_errno;
    assigns \result \from *(path + (0 ..)), __fc_p_opendir;
    assigns __fc_errno \from *(path + (0 ..)), __fc_p_opendir;
 */
extern DIR *opendir(char const *path);

/*@ requires \subset(dirp, &__fc_opendir[0 .. 512 - 1]);
    ensures \result ≡ \null ∨ \valid(\result);
    assigns \result, dirp->__fc_dir_position, __fc_errno;
    assigns \result \from *dirp, __fc_p_opendir;
    assigns dirp->__fc_dir_position \from dirp->__fc_dir_position;
    assigns __fc_errno \from dirp, *dirp, __fc_p_opendir;
 */
extern struct dirent *readdir(DIR *dirp);

/*@ assigns *fdset;
    assigns *fdset \from *fdset, fd; */
extern void FD_CLR(int fd, fd_set *fdset);

/*@ assigns \nothing; */
extern int FD_ISSET(int fd, fd_set *fdset);

/*@ assigns *fdset;
    assigns *fdset \from *fdset, fd; */
extern void FD_SET(int fd, fd_set *fdset);

/*@ assigns *fdset;
    assigns *fdset \from \nothing; */
extern void FD_ZERO(fd_set *fdset);

/*@ assigns \result;
    assigns \result \from *(filename + (0 ..)), mode; */
extern int creat(char const *filename, mode_t mode);

/*@ assigns \result;
    assigns \result \from fd, cmd; */
extern int fcntl(int fd, int cmd, void * const *__va_params);

/*@ assigns \result;
    assigns \result \from *(filename + (0 ..)), flags; */
extern int open(char const *filename, int flags, void * const *__va_params);

/*@ assigns \result;
    assigns \result \from dirfd, *(filename + (0 ..)), flags;
 */
extern int openat(int dirfd, char const *filename, int flags,
                  void * const *__va_params);

/*@ requires valid_cmd: cmd ≡ 2 ∨ cmd ≡ 4 ∨ cmd ≡ 9;
    assigns \result;
    assigns \result \from fd, cmd;
 */
extern int __va_fcntl_void(int fd, int cmd);

/*@ requires valid_cmd: cmd ≡ 1 ∨ cmd ≡ 3 ∨ cmd ≡ 5 ∨ cmd ≡ 10;
    assigns \result;
    assigns \result \from fd, cmd, arg;
 */
extern int __va_fcntl_int(int fd, int cmd, int arg);

/*@ requires valid_cmd: cmd ≡ 6 ∨ cmd ≡ 7 ∨ cmd ≡ 8;
    requires valid_arg: \valid(arg);
    assigns \result, *arg;
    assigns \result \from fd, cmd, *arg;
    assigns *arg \from fd, cmd, *arg;
 */
extern int __va_fcntl_flock(int fd, int cmd, struct flock *arg);

/*@ requires valid_flag: (flags & 0x0200) ≡ 0;
    assigns \result;
    assigns \result \from *(filename + (0 ..)), flags;
 */
extern int __va_open_void(char const *filename, int flags);

/*@ assigns \result;
    assigns \result \from *(filename + (0 ..)), flags, mode;
 */
extern int __va_open_mode_t(char const *filename, int flags, mode_t mode);

/*@ requires valid_flag: (flags & 0x0200) ≡ 0;
    assigns \result;
    assigns \result \from dirfd, *(filename + (0 ..)), flags;
 */
extern int __va_openat_void(int dirfd, char const *filename, int flags);

/*@ assigns \result;
    assigns \result \from dirfd, *(filename + (0 ..)), flags, mode;
 */
extern int __va_openat_mode_t(int dirfd, char const *filename, int flags,
                              mode_t mode);

/*@ ghost unsigned int volatile __fc_time __attribute__((__FRAMA_C_MODEL__));
  */
/*@ ghost extern int __fc_tz __attribute__((__FRAMA_C_MODEL__)); */

/*@ assigns \result;
    assigns \result \from *(path + (0 ..)), *(times + (0 .. 1));
 */
extern int utimes(char const *path, struct timeval const * /*[2]*/ times);

/*@ behavior tv_and_tz_null:
      assumes tv ≡ \null ∧ tz ≡ \null;
      assigns \nothing;
    
    behavior tv_not_null:
      assumes tv ≢ \null ∧ tz ≡ \null;
      ensures
        \initialized(&\old(tv)->tv_sec) ∧ \initialized(&\old(tv)->tv_usec);
      assigns tv->tv_sec, tv->tv_usec;
      assigns tv->tv_sec \from __fc_time;
      assigns tv->tv_usec \from __fc_time;
    
    behavior tz_not_null:
      assumes tv ≡ \null ∧ tz ≢ \null;
      ensures \initialized(\old(tz));
      assigns *tz;
      assigns *tz \from __fc_tz;
    
    behavior tv_and_tz_not_null:
      assumes tv ≢ \null ∧ tz ≢ \null;
      ensures
        \initialized(&\old(tv)->tv_sec) ∧ \initialized(&\old(tv)->tv_usec);
      ensures \initialized(&tz);
      assigns tv->tv_sec, tv->tv_usec, *tz;
      assigns tv->tv_sec \from __fc_time;
      assigns tv->tv_usec \from __fc_time;
      assigns *tz \from __fc_tz;
    
    complete behaviors tv_and_tz_not_null,
                       tz_not_null,
                       tv_not_null,
                       tv_and_tz_null;
    disjoint behaviors tv_and_tz_not_null,
                       tz_not_null,
                       tv_not_null,
                       tv_and_tz_null;
 */
extern int gettimeofday(struct timeval *tv, struct timezone *tz);

/*@ assigns \result, __fc_time, __fc_tz;
    assigns \result
      \from tv->tv_sec, tv->tv_usec, tz->tz_dsttime, tz->tz_minuteswest;
    assigns __fc_time
      \from tv->tv_sec, tv->tv_usec, tz->tz_dsttime, tz->tz_minuteswest;
    assigns __fc_tz
      \from tv->tv_sec, tv->tv_usec, tz->tz_dsttime, tz->tz_minuteswest;
 */
extern int settimeofday(struct timeval const *tv, struct timezone const *tz);

/*@ ghost
  struct itimerval volatile __fc_itimer_real __attribute__((__FRAMA_C_MODEL__));
  */
/*@ ghost
  struct itimerval volatile __fc_itimer_virtual __attribute__((__FRAMA_C_MODEL__));
  */
/*@ ghost
  struct itimerval volatile __fc_itimer_prof __attribute__((__FRAMA_C_MODEL__));
  */
/*@ requires \valid(curr_value);
    ensures \initialized(\old(curr_value));
    assigns \result, *curr_value;
    assigns \result \from (indirect: which);
    assigns *curr_value
      \from __fc_itimer_real, __fc_itimer_virtual, __fc_itimer_prof;
    
    behavior real:
      assumes which ≡ 0;
      ensures \result ≡ 0;
      assigns \result, *curr_value;
      assigns \result \from \nothing;
      assigns *curr_value \from __fc_itimer_real;
    
    behavior virtual:
      assumes which ≡ 1;
      ensures \result ≡ 0;
      assigns \result, *curr_value;
      assigns \result \from \nothing;
      assigns *curr_value \from __fc_itimer_virtual;
    
    behavior prof:
      assumes which ≡ 2;
      ensures \result ≡ 0;
      assigns \result, *curr_value;
      assigns \result \from \nothing;
      assigns *curr_value \from __fc_itimer_prof;
    
    behavior invalid:
      assumes which ≢ 0 ∧ which ≢ 1 ∧ which ≢ 2;
      ensures \result ≡ -1;
      assigns \result;
      assigns \result \from \nothing;
    
    complete behaviors invalid, prof, virtual, real;
    disjoint behaviors invalid, prof, virtual, real;
 */
extern int getitimer(int which, struct itimerval *curr_value);

/*@ requires \valid_read(new_value);
    requires old_value ≡ \null ∨ \valid(old_value);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns old_value ≢ \null? *old_value: \empty, \result;
    assigns old_value ≢ \null? *old_value: \empty
      \from (indirect: which), (indirect: old_value), (indirect: new_value),
            __fc_itimer_real, __fc_itimer_virtual, __fc_itimer_prof;
    assigns \result
      \from (indirect: which), (indirect: new_value), (indirect: *new_value);
    
    behavior real:
      assumes
        which ≡ 0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
        0 ≤ new_value->it_interval.tv_usec ≤ 999999;
      ensures \result ≡ 0;
      ensures \initialized(\old(old_value));
      assigns \result, old_value ≢ \null? *old_value: \empty,
              __fc_itimer_real;
      assigns \result \from \nothing;
      assigns old_value ≢ \null? *old_value: \empty \from __fc_itimer_real;
      assigns __fc_itimer_real \from *new_value;
    
    behavior virtual:
      assumes
        which ≡ 1 ∧ 0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
        0 ≤ new_value->it_interval.tv_usec ≤ 999999;
      ensures \result ≡ 0;
      ensures \initialized(\old(old_value));
      assigns \result, old_value ≢ \null? *old_value: \empty;
      assigns \result \from \nothing;
      assigns old_value ≢ \null? *old_value: \empty
        \from __fc_itimer_virtual;
    
    behavior prof:
      assumes
        which ≡ 2 ∧ 0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
        0 ≤ new_value->it_interval.tv_usec ≤ 999999;
      ensures \result ≡ 0;
      ensures \initialized(\old(old_value));
      assigns \result, old_value ≢ \null? *old_value: \empty;
      assigns \result \from \nothing;
      assigns old_value ≢ \null? *old_value: \empty \from __fc_itimer_prof;
    
    behavior invalid:
      assumes
        (which ≢ 0 ∧ which ≢ 1 ∧ which ≢ 2) ∨
        ¬(0 ≤ new_value->it_value.tv_usec ≤ 999999 ∧
           0 ≤ new_value->it_interval.tv_usec ≤ 999999);
      ensures \result ≡ -1;
      assigns \result;
      assigns \result \from \nothing;
    
    disjoint behaviors invalid, prof, virtual, real;
 */
extern int setitimer(int which, struct itimerval const *new_value,
                     struct itimerval *old_value);

/*@ assigns *(*(outbuf + (0 .. *outbytesleft - 1))), __fc_errno;
    assigns *(*(outbuf + (0 .. *outbytesleft - 1)))
      \from *(*(inbuf + (0 .. *inbytesleft - 1)));
 */
extern size_t iconv(iconv_t cd, char **inbuf, size_t *inbytesleft,
                    char **outbuf, size_t *outbytesleft);

/*@ ensures \result ≡ 0 ∨ \result ≡ 1;
    assigns __fc_errno; */
extern int iconv_close(iconv_t);

/*@ assigns \result, __fc_errno;
    assigns \result \from *(tocode + (..)), *(fromcode + (..));
 */
extern iconv_t iconv_open(char const *tocode, char const *fromcode);

int h_errno;
/*@ assigns *(env + (0 .. 4)); */
extern int setjmp(int * /*[5]*/ env);

/*@ ensures \false;
    assigns \nothing; */
extern void longjmp(int * /*[5]*/ env, int val);

/*@ ensures \false;
    assigns \nothing; */
extern void siglongjmp(sigjmp_buf env, int val);

/*@ assigns \nothing; */
extern void (*signal(int sig, void (*func)(int )))(int );

/*@ ensures \false;
    assigns \nothing; */
extern int raise(int sig);

CODE facilitynames[23] =
  {{.c_name = "auth", .c_val = 4 << 3},
   {.c_name = "authpriv", .c_val = 10 << 3},
   {.c_name = "cron", .c_val = 9 << 3},
   {.c_name = "daemon", .c_val = 3 << 3},
   {.c_name = "ftp", .c_val = 11 << 3},
   {.c_name = "kern", .c_val = 0 << 3},
   {.c_name = "lpr", .c_val = 6 << 3},
   {.c_name = "mail", .c_val = 2 << 3},
   {.c_name = "mark", .c_val = (24 << 3) | 0},
   {.c_name = "news", .c_val = 7 << 3},
   {.c_name = "security", .c_val = 4 << 3},
   {.c_name = "syslog", .c_val = 5 << 3},
   {.c_name = "user", .c_val = 1 << 3},
   {.c_name = "uucp", .c_val = 8 << 3},
   {.c_name = "local0", .c_val = 16 << 3},
   {.c_name = "local1", .c_val = 17 << 3},
   {.c_name = "local2", .c_val = 18 << 3},
   {.c_name = "local3", .c_val = 19 << 3},
   {.c_name = "local4", .c_val = 20 << 3},
   {.c_name = "local5", .c_val = 21 << 3},
   {.c_name = "local6", .c_val = 22 << 3},
   {.c_name = "local7", .c_val = 23 << 3},
   {.c_name = (char const *)0, .c_val = -1}};
CODE prioritynames[13] =
  {{.c_name = "alert", .c_val = 1},
   {.c_name = "crit", .c_val = 2},
   {.c_name = "debug", .c_val = 7},
   {.c_name = "emerg", .c_val = 0},
   {.c_name = "err", .c_val = 3},
   {.c_name = "error", .c_val = 3},
   {.c_name = "info", .c_val = 6},
   {.c_name = "none", .c_val = 0x10},
   {.c_name = "notice", .c_val = 5},
   {.c_name = "panic", .c_val = 0},
   {.c_name = "warn", .c_val = 4},
   {.c_name = "warning", .c_val = 4},
   {.c_name = (char const *)0, .c_val = -1}};
/*@ assigns \nothing; */
extern void closelog(void);

/*@ assigns \nothing; */
extern void openlog(char const *, int, int);

/*@ assigns \nothing; */
extern int setlogmask(int);

/*@ assigns \nothing; */
extern void syslog(int, char const *, void * const *__va_params);

/*@ assigns \result;
    assigns \result \from which, who; */
extern int getpriority(int which, id_t who);

/*@ assigns \result;
    assigns \result \from which, who, prio; */
extern int setpriority(int which, id_t who, int prio);

/*@ assigns \result, rl->rlim_cur, rl->rlim_max;
    assigns \result \from r;
    assigns rl->rlim_cur \from r;
    assigns rl->rlim_max \from r;
 */
extern int getrlimit(int r, struct rlimit *rl);

/*@ assigns \result, ru->ru_utime, ru->ru_stime;
    assigns \result \from r;
    assigns ru->ru_utime \from r;
    assigns ru->ru_stime \from r;
 */
extern int getrusage(int r, struct rusage *ru);

/*@ assigns \result;
    assigns \result \from r, rl->rlim_cur, rl->rlim_max; */
extern int setrlimit(int r, struct rlimit const *rl);

/*@ assigns \result;
    assigns \result \from __fc_time; */
extern clock_t clock(void);

/*@ assigns \result;
    assigns \result \from time1, time0; */
extern double difftime(time_t time1, time_t time0);

/*@ assigns *timeptr, \result;
    assigns *timeptr \from *timeptr;
    assigns \result \from *timeptr;
 */
extern time_t mktime(struct tm *timeptr);

/*@ assigns *timer, \result;
    assigns *timer \from __fc_time;
    assigns \result \from __fc_time;
    
    behavior null:
      assumes timer ≡ \null;
      assigns \result;
      assigns \result \from __fc_time;
    
    behavior not_null:
      assumes timer ≢ \null;
      requires \valid(timer);
      ensures \initialized(\old(timer));
      assigns *timer, \result;
      assigns *timer \from __fc_time;
      assigns \result \from __fc_time;
    
    complete behaviors not_null, null;
    disjoint behaviors not_null, null;
 */
extern time_t time(time_t *timer);

struct tm __fc_time_tm;
struct tm * const __fc_p_time_tm = & __fc_time_tm;
/*@ ensures \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __fc_p_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *gmtime(time_t const *timer);

/*@ ensures \result ≡ &__fc_time_tm ∨ \result ≡ \null;
    assigns \result, __fc_time_tm;
    assigns \result \from __fc_p_time_tm;
    assigns __fc_time_tm \from *timer;
 */
extern struct tm *localtime(time_t const *timer);

/*@ requires \valid(buffer);
    assigns \result, *buffer;
    assigns \result \from __fc_time;
    assigns *buffer \from __fc_time;
 */
extern clock_t times(struct tms *buffer);

/*@ requires \valid_read(iov + (0 .. iovcnt - 1));
    assigns *((char *)(iov + (0 .. iovcnt - 1))->iov_base + (0 ..));
 */
extern ssize_t readv(int fd, struct iovec const *iov, int iovcnt);

/*@ requires \valid(termios_p);
    assigns \result, *termios_p, Frama_C_entropy_source;
    assigns \result \from (indirect: fd), (indirect: Frama_C_entropy_source);
    assigns *termios_p
      \from (indirect: fd), (indirect: Frama_C_entropy_source);
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
    
    behavior ok:
      assumes Frama_C_entropy_source ≡ 0;
      ensures \initialized(\old(termios_p));
      ensures \result ≡ 0;
    
    behavior error:
      assumes Frama_C_entropy_source ≢ 0;
      ensures \result ≡ -1;
    
    complete behaviors ok, error;
    disjoint behaviors ok, error;
 */
extern int tcgetattr(int fd, struct termios *termios_p);

/*@ requires \valid(termios_p);
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns *termios_p, Frama_C_entropy_source, \result;
    assigns *termios_p
      \from (indirect: fd), (indirect: optional_actions),
            (indirect: Frama_C_entropy_source), *termios_p;
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
    assigns \result
      \from (indirect: fd), (indirect: optional_actions),
            (indirect: Frama_C_entropy_source), (indirect: *termios_p);
 */
extern int tcsetattr(int fd, int optional_actions, struct termios *termios_p);

/*@ ghost int __fc_fds[1024]; */
/*@ requires 0 ≤ fd < 1024;
    ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, __fc_fds[fd];
    assigns \result \from fd, __fc_fds[fd];
    assigns __fc_fds[fd] \from fd, __fc_fds[fd];
 */
extern int close(int fd);

/*@ requires arg ≢ \null;
    requires valid_read_string(path);
    requires valid_read_string(arg);
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(arg + (0 ..));
 */
extern int execl(char const *path, char const *arg, void * const *__va_params);

/*@ requires arg ≢ \null;
    requires valid_read_string(path);
    requires valid_read_string(arg);
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(arg + (0 ..));
 */
extern int execle(char const *path, char const *arg,
                  void * const *__va_params);

/*@ requires arg ≢ \null;
    requires valid_read_string(path);
    requires valid_read_string(arg);
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(arg + (0 ..));
 */
extern int execlp(char const *path, char const *arg,
                  void * const *__va_params);

/*@ requires *(argv + 0) ≢ \null;
    requires valid_read_string(path);
    requires valid_read_string(*(argv + 0));
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(argv + (0 ..));
 */
extern int execv(char const *path, char * const *argv);

/*@ requires *(argv + 0) ≢ \null;
    requires valid_read_string(path);
    requires valid_read_string(*(argv + 0));
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(argv + (0 ..));
 */
extern int execve(char const *path, char * const *argv, char * const *env);

/*@ requires *(argv + 0) ≢ \null;
    requires valid_read_string(path);
    requires valid_read_string(*(argv + 0));
    assigns \result;
    assigns \result \from *(path + (0 ..)), *(argv + (0 ..));
 */
extern int execvp(char const *path, char * const *argv);

/*@ assigns \result;
    assigns \result \from \nothing; */
extern uid_t getuid(void);

/*@ requires 0 ≤ fd < 1024;
    requires \valid((char *)buf + (0 .. count - 1));
    ensures (0 ≤ \result ≤ \old(count)) ∨ \result ≡ -1;
    ensures \initialized((char *)\old(buf) + (0 .. \result - 1));
    assigns \result, *((char *)buf + (0 .. count - 1)), __fc_fds[fd];
    assigns \result \from __fc_fds[fd], count;
    assigns *((char *)buf + (0 .. count - 1)) \from __fc_fds[fd], count;
    assigns __fc_fds[fd] \from __fc_fds[fd], count;
 */
extern ssize_t read(int fd, void *buf, size_t count);

/*@ ensures \result ≡ 0 ∨ \result ≡ -1;
    assigns \result, Frama_C_entropy_source;
    assigns \result
      \from (indirect: usec), (indirect: Frama_C_entropy_source);
    assigns Frama_C_entropy_source \from Frama_C_entropy_source;
 */
extern int usleep(useconds_t usec);

/*@ requires 0 ≤ fd < 1024;
    requires \valid_read((char *)buf + (0 .. count - 1));
    ensures -1 ≤ \result ≤ \old(count);
    assigns \result, __fc_fds[fd];
    assigns \result \from fd, count, __fc_fds[fd];
    assigns __fc_fds[fd] \from fd, count, __fc_fds[fd];
 */
extern ssize_t write(int fd, void const *buf, size_t count);

void main(void)
{
  /*@ assert __fc_p_fopen ≡ (FILE *)(&__fc_fopen); */ ;
  /*@ assert __fc_p_opendir ≡ (DIR *)(&__fc_opendir); */ ;
  /*@ assert __fc_p_time_tm ≡ &__fc_time_tm; */ ;
  return;
}


